<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>kawa_scripts.combiner API documentation</title>
<meta name="description" content="Tool for combining few objects into single one.
See `kawa_scripts.combiner.BaseMeshCombiner`." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>kawa_scripts.combiner</code></h1>
</header>
<section id="section-intro">
<p>Tool for combining few objects into single one.
See <code><a title="kawa_scripts.combiner.BaseMeshCombiner" href="#kawa_scripts.combiner.BaseMeshCombiner">BaseMeshCombiner</a></code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Kawashirov&#39;s Scripts (c) 2021 by Sergey V. Kawashirov
#
# Kawashirov&#39;s Scripts is licensed under a
# Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
#
# You should have received a copy of the license along with this
# work.  If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/3.0/&gt;.
#
#
&#34;&#34;&#34;
Tool for combining few objects into single one.
See `kawa_scripts.combiner.BaseMeshCombiner`.
&#34;&#34;&#34;

from collections import deque as _deque

import bpy as _bpy
from bpy import data as _D
from bpy import context as _C

from . import commons as _commons
from .reporter import LambdaReporter as _LambdaReporter
from ._internals import log as _log

import typing as _typing

if _typing.TYPE_CHECKING:
        from typing import *
        from bpy.types import *


class BaseMeshCombiner:
        &#34;&#34;&#34;
        Base class for Combining Meshes.
        You must extend this class with required and necessary methods for your case,
        configure variables and then run `combine_meshes`.
        
        This tool creates/destroys bpy-Objects intensive,       so unique `str` ID names is used for Object-references.
        You must not rename objects while combiner is running.
        You also should be careful with references to related Objects, as it most likely will become invalid.
        
        How does this work:
        
        - You should put an &#34;root&#34; Object ID name into `roots_names`.
                There may be several root objects, it will be combined independently in single run.
                
        - Combiner will try to join all children Objects of given root Object into given root Object itself.
                You can not combine non-children Objects.
                It is assumed that parts of the complex hierarchy will be flattened to a pair of combined objects.
                
        - You can provide a group for given object (See `group_child`). Objects in same group will be joined together.
                Group is a string, but can be `None` for default group or `False` if object must not be combined and should kept as is.
                ..
                This can be used to join all Opaque objects into one Object, and all Transparent objects into different Object.
                For example, I also use this to keep Meshes for rendering and Meshes for collisions separately for Unity.
                
        - Root Object is not required to be a Mesh-Object. This can be any type of object.
                If `force_mesh_root`, then given non-Mesh root Object will be replaced with Mesh Object.
                This can be used to avoid unnecessary empty Objects.
                
        - If root object is a Mesh-Object, children Objects of default group will be joined to the root Object.
        
        - After combining names of newly created objects put into `created_objects`.
                For example, you can use this to switch back to Object-references after running this tool.
        
        Here example hierarchy of raw object before combining:
        
        ![combiner_example_before.png](https://i.imgur.com/hA9Od1G.png)
        
        Here same hierarchy of final objects after combining:
        
        ![combiner_example_after.png](https://i.imgur.com/7QcrBDT.png)
        
        As you can see addition groups `ClldrDynamic`, `ClldrProp` and `NoCast` where used.
        
        &#34;&#34;&#34;
        def __init__(self):
                self.roots_names = set()  # type: Set[str]
                
                self.report_time = 5
                
                # Если указано, ограничивает работу скрипта только этой сценой.
                # Иначе, рассматривается активная сцена.
                self.scene = None  # type: Optional[Scene]
                
                # Объекты, которые были замешены во время работы этого скрипта.
                self.created_objects = set()  # type: Set[str]
                self.replaced_objects = set()  # type: Set[str]
                
                # Если root-объект - не меш-объект, то следует ли пересоздать его?
                # - False - в иерархии root-объекта создается новый меш-объект, для None-группы.
                # Объект будет иметь суффикс .default_group.
                # - True - root-объект будет заменён на новый меш-объект, для None-группы.
                # Пара объектов (заменённый, заменивший) будет сохранена в .recreated
                self.force_mesh_root = False  # type: bool
                
                self.default_group = &#39;Default&#39;  # type: str

        def before_group(self, root: &#39;str&#39;, children: &#39;Set[str]&#39;):
                # Функция, вызываемая перед группировкой детей.
                pass
        
        def group_child(self, root: &#39;str&#39;, child: &#39;str&#39;) -&gt; &#39;Union[None, str, bool]&#39;:
                # Функция, которая говорит, как объединять меши.
                # Аргументы:
                # - объект из root, в который предлагается подсоединить меш
                # - предлагаемый дочерний меш-объект, который предлагается подсоединить к первому
                # Функция должна вернуть одно из:
                # - False если предлагаемый объект объединять не нужно
                # - строку с именем группы объединения
                # - None, что бы объединить в группу по-молчанию / без группы
                # Если root-объект - меш-объект, то объекты с группой None вольются в него.
                # Если root-объект - не меш-объект, то поведение зависит от .force_mesh_root
                return None
        
        def before_join(self, root: &#39;str&#39;, join_to: &#39;str&#39;, group_name: &#39;Optional[str]&#39;, group_objs: &#39;Set[str]&#39;):
                # Функция, вызываемая после создания нового меш-объекта, к которому будет присоединение.
                # Аргументы:
                # - root - исходный объект из root
                # - join_to - куда будет происходить присоединения.
                # - group_name - группа, т.е. то, что вернул .selector
                # - group_objs - объекты (которые выбраны .selector-ом) для присоеднинения
                # Может быть root is join_to
                # Ничего возвращать не нужно.
                # Можно использовать, например, для применения/переноса какх-то свойств объекта
                # или для правки UV для корректного сведения.
                pass
        
        def after_join(self, root: &#39;str&#39;, join_to: &#39;str&#39;, group_name: &#39;Optional[str]&#39;):
                # Функция, вызываемая после присоединения.
                # Аргументы:
                # - root - исходный объект из root
                # - join_to - куда было выполнено присоединение.
                # - group_name - группа, т.е. то, что вернул .selector
                # Может быть root is join_to
                # Ничего возвращать не нужно.
                # Можно использовать, например, для починки lightmap UV.
                pass
        
        def _check_roots(self):
                scene = self.scene or _C.scene
                wrong = list()
                for root_name in self.roots_names:
                        if root_name not in scene.collection.objects:
                                wrong.append(root_name)
                if len(wrong) &gt; 0:
                        wrongstr = &#39;, &#39;.join(&#39;&#34;&#39; + r + &#39;&#34;&#39; for r in wrong)
                        msg = &#39;There is {0} root-objects not from scene &#34;{1}&#34;: {2}.&#39;.format(len(wrong), scene.name, wrongstr)
                        _log.error(msg)
                        raise RuntimeError(msg, wrong)
                
                # Проверяем, что бы объекты в .roots были независимы друг от друга,
                # а именно не были детьми/родителями друг друга.
                # TODO Довольно много итераций, можно ли это как-то ускорить?
                related = list()
                for obja_n in self.roots_names:
                        obja = _D.objects[obja_n]
                        for objb_n in self.roots_names:
                                objb = _D.objects[objb_n]
                                if obja is objb:
                                        continue
                                objc = obja
                                while objc is not None:
                                        if objc is objb:
                                                related.append((obja_n, objb_n))
                                                break
                                        objc = objc.parent
                if len(related) &gt; 0:
                        pairs = &#39;, &#39;.join(&#39;&#34;{0}&#34; is child of &#34;{1}&#34;&#39;.format(a, b) for a, b in related)
                        msg = &#39;There is {0} objects pairs have child-parent relations between each other: {1}.&#39;\
                                .format(len(related), pairs)
                        _log.error(msg)
                        raise RuntimeError(msg, related)

        def _call_before_group(self, root_name: &#39;str&#39;, child_name: &#39;Set[str]&#39;):
                try:
                        self.before_group(root_name, child_name)
                except Exception as exc:
                        raise RuntimeError(root_name, child_name) from exc

        def _call_group_child(self, root_name: &#39;str&#39;, child_name: &#39;str&#39;) -&gt; &#39;Union[False, None, str]&#39;:
                group_name = None
                try:
                        group_name = self.group_child(root_name, child_name)
                        if not isinstance(group_name, (type(None), str)) and group_name is not False:
                                msg = &#39;Group should be None, False or str, got ({0}) &#34;{1}&#34; from .group_child&#39;.format(type(group_name), str(group_name))
                                _log.error(msg)
                                raise RuntimeError(msg, group_name)
                        return group_name
                except Exception as exc:
                        msg = &#39;Can not group object &#34;{0}&#34; in object &#34;{1}&#34; ({2})&#39;.format(child_name, root_name, repr(group_name))
                        _log.error(msg)
                        raise RuntimeError(msg, root_name, child_name, group_name) from exc

        def _join_objects(self, target: &#39;Object&#39;, children: &#39;Iterable[str]&#39;):
                # log.info(&#34;Joining: %s &lt;- %s&#34;, target.name, children)
                _commons.ensure_deselect_all_objects()
                for child_name in children:
                        obj = _D.objects[child_name]
                        obj.hide_set(False)
                        obj.select_set(True)
                        _commons.move_children_to_grandparent(obj)
                _commons.activate_object(target)
                _commons.ensure_op_finished(_bpy.ops.object.join(), name=&#39;bpy.ops.object.join&#39;)
                _commons.ensure_deselect_all_objects()
                # log.info(&#34;Joined: %s &lt;- %s&#34;, target, children)
                pass
        
        def _call_before_join(self, root: &#39;str&#39;, join_to: &#39;str&#39;, group_name: &#39;Optional[str]&#39;, group_objs: &#39;Set[str]&#39;):
                try:
                        self.before_join(root, join_to, group_name, group_objs)
                except Exception as exc:
                        msg = &#39;Error before_join: root={0}, join_to={1}, group_name={2}, group_objs={3}&#39;.format(root, join_to, group_name, group_objs)
                        raise RuntimeError(msg, root, join_to, group_name, group_objs) from exc
        
        def _call_after_join(self, root: &#39;str&#39;, join_to: &#39;str&#39;, group_name: &#39;Optional[str]&#39;):
                try:
                        self.after_join(root, join_to, group_name)
                except Exception as exc:
                        msg = &#39;Error after_join: root={0}, join_to={1}, group_name={2}&#39;.format(root, join_to, group_name)
                        raise RuntimeError(msg, root, join_to, group_name) from exc
        
        def _process_root(self, root_name: &#39;str&#39;) -&gt; &#39;int&#39;:
                # Поиск меш-объектов-детей root на этой же сцене.
                scene_objs = (self.scene or _C.scene).collection.objects
                children_queue = _deque()  # type: Deque[str]
                children = set()  # type: Set[str]
                children_queue.extend(x.name for x in _D.objects[root_name].children)
                while len(children_queue) &gt; 0:
                        child_name = children_queue.pop()
                        child = _D.objects[child_name]
                        children_queue.extend(x.name for x in child.children)
                        if child_name not in scene_objs:
                                continue
                        if not isinstance(child.data, _bpy.types.Mesh):
                                continue
                        children.add(child_name)

                self._call_before_group(root_name, children)
                
                groups = dict()  # type: Dict[Optional[str], Set[str]]
                for child_name in children:
                        group_name = self._call_group_child(root_name, child_name)
                        if group_name is False:
                                continue  # skip
                        group = groups.get(group_name)
                        if group is None:
                                group = set()
                                groups[group_name] = group
                        group.add(child_name)
                
                # log.info(&#39;%s %s&#39;, root_name, repr(groups))
        
                def create_mesh_obj(name):
                        new_mesh = _D.meshes.new(name + &#39;-Mesh&#39;)
                        new_obj = _D.objects.new(name, object_data=new_mesh)
                        new_obj.name = name  # force rename
                        scene_objs.link(new_obj)
                        return new_obj
                
                # Далее намерено избегаем ссылок на root объект, т.к. объекты меняются
                # и можно отхватить ошибку StructRNA of type Object has been removed
                obj_group_count = 0
                for group_name, obj_group in groups.items():
                        join_to = None
                        if group_name is None:
                                if isinstance(_D.objects[root_name].data, _bpy.types.Mesh):
                                        # root - Это меш, приклееваем к нему.
                                        join_to = _D.objects[root_name]
                                elif self.force_mesh_root:
                                        # root - Это НЕ меш, но force_mesh_root.
                                        base_name = root_name
                                        old_root = _D.objects[root_name]
                                        old_root.name = base_name + &#39;-Replaced&#39;
                                        self.replaced_objects.add(old_root.name)
                                        join_to = create_mesh_obj(base_name)
                                        root_name = join_to.name  # Фактическое новое имя
                                        self.created_objects.add(root_name)
                                        join_to.parent = old_root.parent
                                        join_to.parent_type = &#39;OBJECT&#39;
                                        join_to.location = old_root.location
                                        join_to.rotation_mode = old_root.rotation_mode
                                        join_to.rotation_axis_angle = old_root.rotation_axis_angle
                                        join_to.rotation_euler = old_root.rotation_euler
                                        join_to.rotation_quaternion = old_root.rotation_quaternion
                                        join_to.scale = old_root.scale
                                        for sub_child in old_root.children:  # type: Object
                                                sub_child.parent = join_to
                                else:
                                        # root - Это НЕ меш, создаём подгруппу.
                                        join_to = create_mesh_obj(root_name + &#39;-&#39; + self.default_group)
                                        self.created_objects.add(join_to.name)
                                        join_to.parent = _D.objects[root_name]
                                        join_to.parent_type = &#39;OBJECT&#39;
                                        _commons.identity_transform(join_to)
                        else:
                                join_to = create_mesh_obj(root_name + &#39;-&#39; + group_name)
                                self.created_objects.add(join_to.name)
                                join_to.parent = _D.objects[root_name]
                                join_to.parent_type = &#39;OBJECT&#39;
                                _commons.identity_transform(join_to)
                        self._call_before_join(root_name, join_to.name, group_name, obj_group)
                        self._join_objects(join_to, obj_group)
                        self._call_after_join(root_name, join_to.name, group_name)
                        obj_group_count += len(obj_group)
                return obj_group_count
                        
        def combine_meshes(self):
                self._check_roots()
                
                obj_n, obj_i, joins = len(self.roots_names), 0, 0
                reporter = _LambdaReporter(self.report_time)
                reporter.func = lambda r, t: _log.info(
                        &#34;Joining meshes: Roots={0}/{1}, Joined={2}, Time={3:.1f} sec, ETA={4:.1f} sec...&#34;.format(
                                obj_i, obj_n, joins, t, r.get_eta(1.0 * obj_i / obj_n)))
                
                for root_name in self.roots_names:
                        joins += self._process_root(root_name)
                        obj_i += 1
                        reporter.ask_report(False)
                reporter.ask_report(True)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="kawa_scripts.combiner.BaseMeshCombiner"><code class="flex name class">
<span>class <span class="ident">BaseMeshCombiner</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for Combining Meshes.
You must extend this class with required and necessary methods for your case,
configure variables and then run <code>combine_meshes</code>.</p>
<p>This tool creates/destroys bpy-Objects intensive,
so unique <code>str</code> ID names is used for Object-references.
You must not rename objects while combiner is running.
You also should be careful with references to related Objects, as it most likely will become invalid.</p>
<p>How does this work:</p>
<ul>
<li>
<p>You should put an "root" Object ID name into <code>roots_names</code>.
There may be several root objects, it will be combined independently in single run.</p>
</li>
<li>
<p>Combiner will try to join all children Objects of given root Object into given root Object itself.
You can not combine non-children Objects.
It is assumed that parts of the complex hierarchy will be flattened to a pair of combined objects.</p>
</li>
<li>
<p>You can provide a group for given object (See <code>group_child</code>). Objects in same group will be joined together.
Group is a string, but can be <code>None</code> for default group or <code>False</code> if object must not be combined and should kept as is.
..
This can be used to join all Opaque objects into one Object, and all Transparent objects into different Object.
For example, I also use this to keep Meshes for rendering and Meshes for collisions separately for Unity.</p>
</li>
<li>
<p>Root Object is not required to be a Mesh-Object. This can be any type of object.
If <code>force_mesh_root</code>, then given non-Mesh root Object will be replaced with Mesh Object.
This can be used to avoid unnecessary empty Objects.</p>
</li>
<li>
<p>If root object is a Mesh-Object, children Objects of default group will be joined to the root Object.</p>
</li>
<li>
<p>After combining names of newly created objects put into <code>created_objects</code>.
For example, you can use this to switch back to Object-references after running this tool.</p>
</li>
</ul>
<p>Here example hierarchy of raw object before combining:</p>
<p><img alt="combiner_example_before.png" src="https://i.imgur.com/hA9Od1G.png"></p>
<p>Here same hierarchy of final objects after combining:</p>
<p><img alt="combiner_example_after.png" src="https://i.imgur.com/7QcrBDT.png"></p>
<p>As you can see addition groups <code>ClldrDynamic</code>, <code>ClldrProp</code> and <code>NoCast</code> where used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseMeshCombiner:
        &#34;&#34;&#34;
        Base class for Combining Meshes.
        You must extend this class with required and necessary methods for your case,
        configure variables and then run `combine_meshes`.
        
        This tool creates/destroys bpy-Objects intensive,       so unique `str` ID names is used for Object-references.
        You must not rename objects while combiner is running.
        You also should be careful with references to related Objects, as it most likely will become invalid.
        
        How does this work:
        
        - You should put an &#34;root&#34; Object ID name into `roots_names`.
                There may be several root objects, it will be combined independently in single run.
                
        - Combiner will try to join all children Objects of given root Object into given root Object itself.
                You can not combine non-children Objects.
                It is assumed that parts of the complex hierarchy will be flattened to a pair of combined objects.
                
        - You can provide a group for given object (See `group_child`). Objects in same group will be joined together.
                Group is a string, but can be `None` for default group or `False` if object must not be combined and should kept as is.
                ..
                This can be used to join all Opaque objects into one Object, and all Transparent objects into different Object.
                For example, I also use this to keep Meshes for rendering and Meshes for collisions separately for Unity.
                
        - Root Object is not required to be a Mesh-Object. This can be any type of object.
                If `force_mesh_root`, then given non-Mesh root Object will be replaced with Mesh Object.
                This can be used to avoid unnecessary empty Objects.
                
        - If root object is a Mesh-Object, children Objects of default group will be joined to the root Object.
        
        - After combining names of newly created objects put into `created_objects`.
                For example, you can use this to switch back to Object-references after running this tool.
        
        Here example hierarchy of raw object before combining:
        
        ![combiner_example_before.png](https://i.imgur.com/hA9Od1G.png)
        
        Here same hierarchy of final objects after combining:
        
        ![combiner_example_after.png](https://i.imgur.com/7QcrBDT.png)
        
        As you can see addition groups `ClldrDynamic`, `ClldrProp` and `NoCast` where used.
        
        &#34;&#34;&#34;
        def __init__(self):
                self.roots_names = set()  # type: Set[str]
                
                self.report_time = 5
                
                # Если указано, ограничивает работу скрипта только этой сценой.
                # Иначе, рассматривается активная сцена.
                self.scene = None  # type: Optional[Scene]
                
                # Объекты, которые были замешены во время работы этого скрипта.
                self.created_objects = set()  # type: Set[str]
                self.replaced_objects = set()  # type: Set[str]
                
                # Если root-объект - не меш-объект, то следует ли пересоздать его?
                # - False - в иерархии root-объекта создается новый меш-объект, для None-группы.
                # Объект будет иметь суффикс .default_group.
                # - True - root-объект будет заменён на новый меш-объект, для None-группы.
                # Пара объектов (заменённый, заменивший) будет сохранена в .recreated
                self.force_mesh_root = False  # type: bool
                
                self.default_group = &#39;Default&#39;  # type: str

        def before_group(self, root: &#39;str&#39;, children: &#39;Set[str]&#39;):
                # Функция, вызываемая перед группировкой детей.
                pass
        
        def group_child(self, root: &#39;str&#39;, child: &#39;str&#39;) -&gt; &#39;Union[None, str, bool]&#39;:
                # Функция, которая говорит, как объединять меши.
                # Аргументы:
                # - объект из root, в который предлагается подсоединить меш
                # - предлагаемый дочерний меш-объект, который предлагается подсоединить к первому
                # Функция должна вернуть одно из:
                # - False если предлагаемый объект объединять не нужно
                # - строку с именем группы объединения
                # - None, что бы объединить в группу по-молчанию / без группы
                # Если root-объект - меш-объект, то объекты с группой None вольются в него.
                # Если root-объект - не меш-объект, то поведение зависит от .force_mesh_root
                return None
        
        def before_join(self, root: &#39;str&#39;, join_to: &#39;str&#39;, group_name: &#39;Optional[str]&#39;, group_objs: &#39;Set[str]&#39;):
                # Функция, вызываемая после создания нового меш-объекта, к которому будет присоединение.
                # Аргументы:
                # - root - исходный объект из root
                # - join_to - куда будет происходить присоединения.
                # - group_name - группа, т.е. то, что вернул .selector
                # - group_objs - объекты (которые выбраны .selector-ом) для присоеднинения
                # Может быть root is join_to
                # Ничего возвращать не нужно.
                # Можно использовать, например, для применения/переноса какх-то свойств объекта
                # или для правки UV для корректного сведения.
                pass
        
        def after_join(self, root: &#39;str&#39;, join_to: &#39;str&#39;, group_name: &#39;Optional[str]&#39;):
                # Функция, вызываемая после присоединения.
                # Аргументы:
                # - root - исходный объект из root
                # - join_to - куда было выполнено присоединение.
                # - group_name - группа, т.е. то, что вернул .selector
                # Может быть root is join_to
                # Ничего возвращать не нужно.
                # Можно использовать, например, для починки lightmap UV.
                pass
        
        def _check_roots(self):
                scene = self.scene or _C.scene
                wrong = list()
                for root_name in self.roots_names:
                        if root_name not in scene.collection.objects:
                                wrong.append(root_name)
                if len(wrong) &gt; 0:
                        wrongstr = &#39;, &#39;.join(&#39;&#34;&#39; + r + &#39;&#34;&#39; for r in wrong)
                        msg = &#39;There is {0} root-objects not from scene &#34;{1}&#34;: {2}.&#39;.format(len(wrong), scene.name, wrongstr)
                        _log.error(msg)
                        raise RuntimeError(msg, wrong)
                
                # Проверяем, что бы объекты в .roots были независимы друг от друга,
                # а именно не были детьми/родителями друг друга.
                # TODO Довольно много итераций, можно ли это как-то ускорить?
                related = list()
                for obja_n in self.roots_names:
                        obja = _D.objects[obja_n]
                        for objb_n in self.roots_names:
                                objb = _D.objects[objb_n]
                                if obja is objb:
                                        continue
                                objc = obja
                                while objc is not None:
                                        if objc is objb:
                                                related.append((obja_n, objb_n))
                                                break
                                        objc = objc.parent
                if len(related) &gt; 0:
                        pairs = &#39;, &#39;.join(&#39;&#34;{0}&#34; is child of &#34;{1}&#34;&#39;.format(a, b) for a, b in related)
                        msg = &#39;There is {0} objects pairs have child-parent relations between each other: {1}.&#39;\
                                .format(len(related), pairs)
                        _log.error(msg)
                        raise RuntimeError(msg, related)

        def _call_before_group(self, root_name: &#39;str&#39;, child_name: &#39;Set[str]&#39;):
                try:
                        self.before_group(root_name, child_name)
                except Exception as exc:
                        raise RuntimeError(root_name, child_name) from exc

        def _call_group_child(self, root_name: &#39;str&#39;, child_name: &#39;str&#39;) -&gt; &#39;Union[False, None, str]&#39;:
                group_name = None
                try:
                        group_name = self.group_child(root_name, child_name)
                        if not isinstance(group_name, (type(None), str)) and group_name is not False:
                                msg = &#39;Group should be None, False or str, got ({0}) &#34;{1}&#34; from .group_child&#39;.format(type(group_name), str(group_name))
                                _log.error(msg)
                                raise RuntimeError(msg, group_name)
                        return group_name
                except Exception as exc:
                        msg = &#39;Can not group object &#34;{0}&#34; in object &#34;{1}&#34; ({2})&#39;.format(child_name, root_name, repr(group_name))
                        _log.error(msg)
                        raise RuntimeError(msg, root_name, child_name, group_name) from exc

        def _join_objects(self, target: &#39;Object&#39;, children: &#39;Iterable[str]&#39;):
                # log.info(&#34;Joining: %s &lt;- %s&#34;, target.name, children)
                _commons.ensure_deselect_all_objects()
                for child_name in children:
                        obj = _D.objects[child_name]
                        obj.hide_set(False)
                        obj.select_set(True)
                        _commons.move_children_to_grandparent(obj)
                _commons.activate_object(target)
                _commons.ensure_op_finished(_bpy.ops.object.join(), name=&#39;bpy.ops.object.join&#39;)
                _commons.ensure_deselect_all_objects()
                # log.info(&#34;Joined: %s &lt;- %s&#34;, target, children)
                pass
        
        def _call_before_join(self, root: &#39;str&#39;, join_to: &#39;str&#39;, group_name: &#39;Optional[str]&#39;, group_objs: &#39;Set[str]&#39;):
                try:
                        self.before_join(root, join_to, group_name, group_objs)
                except Exception as exc:
                        msg = &#39;Error before_join: root={0}, join_to={1}, group_name={2}, group_objs={3}&#39;.format(root, join_to, group_name, group_objs)
                        raise RuntimeError(msg, root, join_to, group_name, group_objs) from exc
        
        def _call_after_join(self, root: &#39;str&#39;, join_to: &#39;str&#39;, group_name: &#39;Optional[str]&#39;):
                try:
                        self.after_join(root, join_to, group_name)
                except Exception as exc:
                        msg = &#39;Error after_join: root={0}, join_to={1}, group_name={2}&#39;.format(root, join_to, group_name)
                        raise RuntimeError(msg, root, join_to, group_name) from exc
        
        def _process_root(self, root_name: &#39;str&#39;) -&gt; &#39;int&#39;:
                # Поиск меш-объектов-детей root на этой же сцене.
                scene_objs = (self.scene or _C.scene).collection.objects
                children_queue = _deque()  # type: Deque[str]
                children = set()  # type: Set[str]
                children_queue.extend(x.name for x in _D.objects[root_name].children)
                while len(children_queue) &gt; 0:
                        child_name = children_queue.pop()
                        child = _D.objects[child_name]
                        children_queue.extend(x.name for x in child.children)
                        if child_name not in scene_objs:
                                continue
                        if not isinstance(child.data, _bpy.types.Mesh):
                                continue
                        children.add(child_name)

                self._call_before_group(root_name, children)
                
                groups = dict()  # type: Dict[Optional[str], Set[str]]
                for child_name in children:
                        group_name = self._call_group_child(root_name, child_name)
                        if group_name is False:
                                continue  # skip
                        group = groups.get(group_name)
                        if group is None:
                                group = set()
                                groups[group_name] = group
                        group.add(child_name)
                
                # log.info(&#39;%s %s&#39;, root_name, repr(groups))
        
                def create_mesh_obj(name):
                        new_mesh = _D.meshes.new(name + &#39;-Mesh&#39;)
                        new_obj = _D.objects.new(name, object_data=new_mesh)
                        new_obj.name = name  # force rename
                        scene_objs.link(new_obj)
                        return new_obj
                
                # Далее намерено избегаем ссылок на root объект, т.к. объекты меняются
                # и можно отхватить ошибку StructRNA of type Object has been removed
                obj_group_count = 0
                for group_name, obj_group in groups.items():
                        join_to = None
                        if group_name is None:
                                if isinstance(_D.objects[root_name].data, _bpy.types.Mesh):
                                        # root - Это меш, приклееваем к нему.
                                        join_to = _D.objects[root_name]
                                elif self.force_mesh_root:
                                        # root - Это НЕ меш, но force_mesh_root.
                                        base_name = root_name
                                        old_root = _D.objects[root_name]
                                        old_root.name = base_name + &#39;-Replaced&#39;
                                        self.replaced_objects.add(old_root.name)
                                        join_to = create_mesh_obj(base_name)
                                        root_name = join_to.name  # Фактическое новое имя
                                        self.created_objects.add(root_name)
                                        join_to.parent = old_root.parent
                                        join_to.parent_type = &#39;OBJECT&#39;
                                        join_to.location = old_root.location
                                        join_to.rotation_mode = old_root.rotation_mode
                                        join_to.rotation_axis_angle = old_root.rotation_axis_angle
                                        join_to.rotation_euler = old_root.rotation_euler
                                        join_to.rotation_quaternion = old_root.rotation_quaternion
                                        join_to.scale = old_root.scale
                                        for sub_child in old_root.children:  # type: Object
                                                sub_child.parent = join_to
                                else:
                                        # root - Это НЕ меш, создаём подгруппу.
                                        join_to = create_mesh_obj(root_name + &#39;-&#39; + self.default_group)
                                        self.created_objects.add(join_to.name)
                                        join_to.parent = _D.objects[root_name]
                                        join_to.parent_type = &#39;OBJECT&#39;
                                        _commons.identity_transform(join_to)
                        else:
                                join_to = create_mesh_obj(root_name + &#39;-&#39; + group_name)
                                self.created_objects.add(join_to.name)
                                join_to.parent = _D.objects[root_name]
                                join_to.parent_type = &#39;OBJECT&#39;
                                _commons.identity_transform(join_to)
                        self._call_before_join(root_name, join_to.name, group_name, obj_group)
                        self._join_objects(join_to, obj_group)
                        self._call_after_join(root_name, join_to.name, group_name)
                        obj_group_count += len(obj_group)
                return obj_group_count
                        
        def combine_meshes(self):
                self._check_roots()
                
                obj_n, obj_i, joins = len(self.roots_names), 0, 0
                reporter = _LambdaReporter(self.report_time)
                reporter.func = lambda r, t: _log.info(
                        &#34;Joining meshes: Roots={0}/{1}, Joined={2}, Time={3:.1f} sec, ETA={4:.1f} sec...&#34;.format(
                                obj_i, obj_n, joins, t, r.get_eta(1.0 * obj_i / obj_n)))
                
                for root_name in self.roots_names:
                        joins += self._process_root(root_name)
                        obj_i += 1
                        reporter.ask_report(False)
                reporter.ask_report(True)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="kawa_scripts.combiner.BaseMeshCombiner.after_join"><code class="name flex">
<span>def <span class="ident">after_join</span></span>(<span>self, root: str, join_to: str, group_name: Optional[str])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def after_join(self, root: &#39;str&#39;, join_to: &#39;str&#39;, group_name: &#39;Optional[str]&#39;):
        # Функция, вызываемая после присоединения.
        # Аргументы:
        # - root - исходный объект из root
        # - join_to - куда было выполнено присоединение.
        # - group_name - группа, т.е. то, что вернул .selector
        # Может быть root is join_to
        # Ничего возвращать не нужно.
        # Можно использовать, например, для починки lightmap UV.
        pass</code></pre>
</details>
</dd>
<dt id="kawa_scripts.combiner.BaseMeshCombiner.before_group"><code class="name flex">
<span>def <span class="ident">before_group</span></span>(<span>self, root: str, children: Set[str])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def before_group(self, root: &#39;str&#39;, children: &#39;Set[str]&#39;):
        # Функция, вызываемая перед группировкой детей.
        pass</code></pre>
</details>
</dd>
<dt id="kawa_scripts.combiner.BaseMeshCombiner.before_join"><code class="name flex">
<span>def <span class="ident">before_join</span></span>(<span>self, root: str, join_to: str, group_name: Optional[str], group_objs: Set[str])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def before_join(self, root: &#39;str&#39;, join_to: &#39;str&#39;, group_name: &#39;Optional[str]&#39;, group_objs: &#39;Set[str]&#39;):
        # Функция, вызываемая после создания нового меш-объекта, к которому будет присоединение.
        # Аргументы:
        # - root - исходный объект из root
        # - join_to - куда будет происходить присоединения.
        # - group_name - группа, т.е. то, что вернул .selector
        # - group_objs - объекты (которые выбраны .selector-ом) для присоеднинения
        # Может быть root is join_to
        # Ничего возвращать не нужно.
        # Можно использовать, например, для применения/переноса какх-то свойств объекта
        # или для правки UV для корректного сведения.
        pass</code></pre>
</details>
</dd>
<dt id="kawa_scripts.combiner.BaseMeshCombiner.combine_meshes"><code class="name flex">
<span>def <span class="ident">combine_meshes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_meshes(self):
        self._check_roots()
        
        obj_n, obj_i, joins = len(self.roots_names), 0, 0
        reporter = _LambdaReporter(self.report_time)
        reporter.func = lambda r, t: _log.info(
                &#34;Joining meshes: Roots={0}/{1}, Joined={2}, Time={3:.1f} sec, ETA={4:.1f} sec...&#34;.format(
                        obj_i, obj_n, joins, t, r.get_eta(1.0 * obj_i / obj_n)))
        
        for root_name in self.roots_names:
                joins += self._process_root(root_name)
                obj_i += 1
                reporter.ask_report(False)
        reporter.ask_report(True)</code></pre>
</details>
</dd>
<dt id="kawa_scripts.combiner.BaseMeshCombiner.group_child"><code class="name flex">
<span>def <span class="ident">group_child</span></span>(<span>self, root: str, child: str) ‑> Union[None, str, bool]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_child(self, root: &#39;str&#39;, child: &#39;str&#39;) -&gt; &#39;Union[None, str, bool]&#39;:
        # Функция, которая говорит, как объединять меши.
        # Аргументы:
        # - объект из root, в который предлагается подсоединить меш
        # - предлагаемый дочерний меш-объект, который предлагается подсоединить к первому
        # Функция должна вернуть одно из:
        # - False если предлагаемый объект объединять не нужно
        # - строку с именем группы объединения
        # - None, что бы объединить в группу по-молчанию / без группы
        # Если root-объект - меш-объект, то объекты с группой None вольются в него.
        # Если root-объект - не меш-объект, то поведение зависит от .force_mesh_root
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="kawa_scripts" href="index.html">kawa_scripts</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="kawa_scripts.combiner.BaseMeshCombiner" href="#kawa_scripts.combiner.BaseMeshCombiner">BaseMeshCombiner</a></code></h4>
<ul class="">
<li><code><a title="kawa_scripts.combiner.BaseMeshCombiner.after_join" href="#kawa_scripts.combiner.BaseMeshCombiner.after_join">after_join</a></code></li>
<li><code><a title="kawa_scripts.combiner.BaseMeshCombiner.before_group" href="#kawa_scripts.combiner.BaseMeshCombiner.before_group">before_group</a></code></li>
<li><code><a title="kawa_scripts.combiner.BaseMeshCombiner.before_join" href="#kawa_scripts.combiner.BaseMeshCombiner.before_join">before_join</a></code></li>
<li><code><a title="kawa_scripts.combiner.BaseMeshCombiner.combine_meshes" href="#kawa_scripts.combiner.BaseMeshCombiner.combine_meshes">combine_meshes</a></code></li>
<li><code><a title="kawa_scripts.combiner.BaseMeshCombiner.group_child" href="#kawa_scripts.combiner.BaseMeshCombiner.group_child">group_child</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>