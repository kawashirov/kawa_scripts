<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc ???" />
<title>kawa_scripts.shapekeys API documentation</title>
<meta name="description" content="Useful tools for Shape Keys …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>kawa_scripts.shapekeys</code></h1>
</header>
<section id="section-intro">
<p>Useful tools for Shape Keys</p>
<p><strong>Most of the functions available as operators from UI:</strong></p>
<p>In "<em>Shape Keys</em>" area in "<em>Properties</em>" editor window:</p>
<p><img alt="menu_shapekeys.png" src="https://i.imgur.com/hqzhUqy.png"></p>
<p>In Object context menu in "<em>3D Viewport</em>" window at Object-mode:</p>
<p><img alt="menu_object.png" src="https://i.imgur.com/I8DAm2u.png"></p>
<p>In Vertex context menu in "<em>3D Viewport</em>" window at Mesh-Edit-mode:</p>
<p><img alt="menu_vertex.png" src="https://i.imgur.com/CZtWPHN.png"></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Kawashirov&#39;s Scripts (c) 2021 by Sergey V. Kawashirov
#
# Kawashirov&#39;s Scripts is licensed under a
# Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
#
# You should have received a copy of the license along with this
# work.  If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/3.0/&gt;.
#
#
&#34;&#34;&#34;
Useful tools for Shape Keys

**Most of the functions available as operators from UI:**

In &#34;*Shape Keys*&#34; area in &#34;*Properties*&#34; editor window:

![menu_shapekeys.png](https://i.imgur.com/hqzhUqy.png)

In Object context menu in &#34;*3D Viewport*&#34; window at Object-mode:

![menu_object.png](https://i.imgur.com/I8DAm2u.png)

In Vertex context menu in &#34;*3D Viewport*&#34; window at Mesh-Edit-mode:

![menu_vertex.png](https://i.imgur.com/CZtWPHN.png)

&#34;&#34;&#34;

import bpy as _bpy
from bpy import context as _C

from ._internals import log as _log
from ._internals import KawaOperator as _KawaOperator
from . import _doc

import typing as _typing

if _typing.TYPE_CHECKING:
        from typing import *
        from bpy.types import *


def ensure_len_match(mesh: &#39;Mesh&#39;, shape_key: &#39;ShapeKey&#39;, op: &#39;Operator&#39; = None):
        &#34;&#34;&#34;
        Ensure `len(mesh.vertices) == len(shape_key.data)`. Helps to detect corrupted Mesh/Key datablocks.
        &#34;&#34;&#34;
        len_vts = len(mesh.vertices)
        len_skd = len(shape_key.data)
        if len_vts == len_skd:
                return True
        _log.error(&#34;Size of {0} ({1}) and size of {2} ({3}) does not match! Is shape key corrupted?&#34;
                .format(repr(mesh.vertices), len_vts, repr(shape_key.data), len_skd), op=op)
        return False


def _mesh_have_shapekeys(mesh: &#39;Mesh&#39;, n: int = 1):
        return mesh is not None and mesh.shape_keys is not None and len(mesh.shape_keys.key_blocks) &gt;= n


def _obj_have_shapekeys(obj: &#39;Object&#39;, n: int = 1):
        return obj is not None and obj.type == &#39;MESH&#39; and _mesh_have_shapekeys(obj.data, n=n)


def _mesh_selection_to_vertices(mesh: &#39;Mesh&#39;):
        for p in mesh.polygons:
                if p.select:
                        for i in p.vertices:
                                mesh.vertices[i].select = True
        for e in mesh.edges:
                if e.select:
                        for i in e.vertices:
                                mesh.vertices[i].select = True


class OperatorSelectVerticesAffectedByShapeKey(_KawaOperator):
        &#34;&#34;&#34;
        **Select Vertices Affected by Active Shape Key.**
        &#34;&#34;&#34;
        bl_idname = &#34;kawa.select_vertices_affected_by_shape_key&#34;
        bl_label = &#34;Select Vertices Affected by Active Shape Key&#34;
        bl_description = &#34;Select Vertices Affected by Active Shape Key.&#34;
        bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}

        epsilon: _bpy.props.FloatProperty(
                name=&#34;Epsilon&#34;,
                description=&#34;Selection precision in local space&#34;,
                min=1e-07,
                default=1e-06,
                max=1,
                precision=6,
                unit=&#39;LENGTH&#39;
        )
        
        @classmethod
        def poll(cls, context: &#39;Context&#39;):
                obj = cls.get_active_obj(context)
                if not obj or obj.type != &#39;MESH&#39;:
                        return False  # Требуется активный меш-объект
                if not obj.active_shape_key or obj.active_shape_key_index == 0:
                        return False  # Требуется что бы был активный не первый шейпкей
                if context.mode != &#39;EDIT_MESH&#39; and context.mode != &#39;OBJECT&#39;:
                        return False  # Требуется режим OBJECT или EDIT_MESH
                return True
        
        def invoke(self, context: &#39;Context&#39;, event):
                wm = context.window_manager
                # return wm.invoke_props_popup(self, event)
                # return {&#39;RUNNING_MODAL&#39;}
                return wm.invoke_props_dialog(self)
        
        def execute(self, context: &#39;Context&#39;):
                # Рофл в том, что операции над мешью надо проводить вне эдит-мода
                _bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;, toggle=False)
                
                obj = self.get_active_obj(context)
                mesh = obj.data  # type: Mesh
                shape_key = obj.active_shape_key
                reference = mesh.shape_keys.reference_key
                
                match_skd = ensure_len_match(mesh, shape_key, op=self)
                match_ref = ensure_len_match(mesh, reference, op=self)
                if not match_skd or not match_ref:
                        return {&#39;CANCELLED&#39;}

                for p in mesh.polygons:
                        p.select = False
                for e in mesh.edges:
                        e.select = False
                
                counter = 0
                for i in range(len(mesh.vertices)):
                        mesh.vertices[i].select = (shape_key.data[i].co - reference.data[i].co).magnitude &gt; self.epsilon
                        counter += 1
                _log.info(&#34;Selected {0} vertices affected by {1} in {2}&#34;.format(counter, repr(shape_key), repr(obj)))
                
                _bpy.ops.object.mode_set_with_submode(mode=&#39;EDIT&#39;, toggle=False, mesh_select_mode={&#39;VERT&#39;})
                
                return {&#39;FINISHED&#39;}


class OperatorRevertSelectedInActiveToBasis(_KawaOperator):
        &#34;&#34;&#34;
        **Revert selected vertices in edit-mode to Reference Shape Key (Basis) in active Shape Key.**
        &#34;&#34;&#34;
        bl_idname = &#34;kawa.revert_selected_shape_keys_in_active_to_basis&#34;
        bl_label = &#34;REVERT SELECTED Vertices in ACTIVE Shape Key to BASIS&#34;
        bl_description = &#34;Revert selected vertices in edit-mode to Reference Shape Key (Basis) in active Shape Key.&#34;
        bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}
        
        @classmethod
        def poll(cls, context: &#39;Context&#39;):
                obj = cls.get_active_obj(context)
                if not obj or obj.type != &#39;MESH&#39;:
                        return False  # Требуется активный меш-объект
                if not obj.active_shape_key or obj.active_shape_key_index == 0:
                        return False  # Требуется что бы был активный не первый шейпкей
                if context.mode != &#39;EDIT_MESH&#39;:
                        return False  # Требуется режим  EDIT_MESH
                return True
        
        def execute(self, context: &#39;Context&#39;):
                obj = self.get_active_obj(context)
                # Рофл в том, что операции над мешью надо проводить вне эдит-мода
                _bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;, toggle=False)
                mesh = obj.data  # type: Mesh
                shape_key = obj.active_shape_key
                reference = mesh.shape_keys.reference_key
                
                match_skd = ensure_len_match(mesh, shape_key, op=self)
                match_ref = ensure_len_match(mesh, reference, op=self)
                if not match_skd or not match_ref:
                        return {&#39;CANCELLED&#39;}
                
                _mesh_selection_to_vertices(mesh)
                
                for i in range(len(mesh.vertices)):
                        if mesh.vertices[i].select:
                                shape_key.data[i].co = reference.data[i].co.copy()
                
                _bpy.ops.object.mode_set_with_submode(mode=&#39;EDIT&#39;, toggle=False, mesh_select_mode={&#39;VERT&#39;})
                
                return {&#39;FINISHED&#39;}


class OperatorRevertSelectedInAllToBasis(_KawaOperator):
        &#34;&#34;&#34;
        **Revert selected vertices in edit-mode to Reference Shape Key (Basis) in every Shape Key.**
        &#34;&#34;&#34;
        bl_idname = &#34;kawa.revert_selected_shape_keys_in_all_to_basis&#34;
        bl_label = &#34;REVERT SELECTED Vertices in ALL Shape Keys to BASIS&#34;
        bl_description = &#34;Revert selected vertices in edit-mode to Reference Shape Key (Basis) in every Shape Key.&#34;
        bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}
        
        @classmethod
        def poll(cls, context: &#39;Context&#39;):
                obj = cls.get_active_obj(context)
                if not obj or obj.type != &#39;MESH&#39;:
                        return False  # Требуется активный меш-объект
                data = obj.data  # type: Mesh
                if data.shape_keys is None or len(data.shape_keys.key_blocks) &lt; 2:
                        return False  # Требуется что бы было 2 или более шейпкея
                if context.mode != &#39;EDIT_MESH&#39;:
                        return False  # Требуется режим  EDIT_MESH
                return True
        
        def execute(self, context: &#39;Context&#39;):
                obj = self.get_active_obj(context)
                # Рофл в том, что операции над мешью надо проводить вне эдит-мода
                _bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;, toggle=False)
                mesh = obj.data  # type: Mesh
                reference = mesh.shape_keys.reference_key
                
                if not ensure_len_match(mesh, reference, op=self):
                        return {&#39;CANCELLED&#39;}
                
                _mesh_selection_to_vertices(mesh)
                
                for shape_key in mesh.shape_keys.key_blocks:
                        if shape_key == reference:
                                continue
                        if not ensure_len_match(mesh, shape_key, op=self):
                                continue
                        for i in range(len(mesh.vertices)):
                                if mesh.vertices[i].select:
                                        shape_key.data[i].co = reference.data[i].co.copy()
                
                _bpy.ops.object.mode_set_with_submode(mode=&#39;EDIT&#39;, toggle=False, mesh_select_mode={&#39;VERT&#39;})
                
                return {&#39;FINISHED&#39;}


class OperatorApplySelectedInActiveToBasis(_KawaOperator):
        &#34;&#34;&#34;
        Same as `OperatorApplyActiveToBasis`, but only for selected vertices in edit-mode.
        See also: `apply_active_to_basis`.
        &#34;&#34;&#34;
        bl_idname = &#34;kawa.apply_selected_shape_keys_in_active_to_basis&#34;
        bl_label = &#34;APPLY SELECTED Vertices in ACTIVE Shape Key to Basis&#34;
        # bl_description at the end of file.
        bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}
        
        @classmethod
        def poll(cls, context: &#39;Context&#39;):
                obj = cls.get_active_obj(context)
                if not obj or obj.type != &#39;MESH&#39;:
                        return False  # Требуется активный меш-объект
                if not obj.active_shape_key or obj.active_shape_key_index == 0:
                        return False  # Требуется что бы был активный не первый шейпкей
                if context.mode != &#39;EDIT_MESH&#39;:
                        return False  # Требуется режим  EDIT_MESH
                return True
        
        def execute(self, context: &#39;Context&#39;):
                obj = self.get_active_obj(context)
                # Рофл в том, что операции над мешью надо проводить вне эдит-мода
                _bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;, toggle=False)
                mesh = obj.data  # type: Mesh
                active_key = obj.active_shape_key
                ref_key = mesh.shape_keys.reference_key
                
                match_active = ensure_len_match(mesh, active_key, op=self)
                match_ref = ensure_len_match(mesh, ref_key, op=self)
                if not match_active or not match_ref:
                        return {&#39;CANCELLED&#39;}
                
                _mesh_selection_to_vertices(mesh)
                
                for i in range(len(mesh.vertices)):
                        if mesh.vertices[i].select:
                                ref_key.data[i].co = active_key.data[i].co.copy()
                
                _bpy.ops.object.mode_set_with_submode(mode=&#39;EDIT&#39;, toggle=False, mesh_select_mode={&#39;VERT&#39;})
                
                return {&#39;FINISHED&#39;}


class OperatorApplySelectedInActiveToAll(_KawaOperator):
        &#34;&#34;&#34;
        Same as `OperatorApplyActiveToAll`, but only for selected vertices in edit-mode.
        See also: `apply_active_to_all`.
        &#34;&#34;&#34;
        bl_idname = &#34;kawa.apply_selected_shape_keys_in_active_to_all&#34;
        bl_label = &#34;APPLY SELECTED Vertices in ACTIVE Shape Key to ALL Others&#34;
        # bl_description at the end of file.
        bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}
        
        @classmethod
        def poll(cls, context: &#39;Context&#39;):
                obj = cls.get_active_obj(context)
                if not obj or obj.type != &#39;MESH&#39;:
                        return False  # Требуется активный меш-объект
                if not obj.active_shape_key or obj.active_shape_key_index == 0:
                        return False  # Требуется что бы был активный не первый шейпкей
                if context.mode != &#39;EDIT_MESH&#39;:
                        return False  # Требуется режим  EDIT_MESH
                return True
        
        def execute(self, context: &#39;Context&#39;):
                obj = self.get_active_obj(context)
                # Рофл в том, что операции над мешью надо проводить вне эдит-мода
                _bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;, toggle=False)
                mesh = obj.data  # type: Mesh
                active_key = obj.active_shape_key
                ref_key = mesh.shape_keys.reference_key
                
                match_active = ensure_len_match(mesh, active_key, op=self)
                match_ref = ensure_len_match(mesh, ref_key, op=self)
                if not match_active or not match_ref:
                        return {&#39;CANCELLED&#39;}
                
                _mesh_selection_to_vertices(mesh)
                
                for other_key in mesh.shape_keys.key_blocks:
                        if other_key == active_key or other_key == ref_key:
                                continue
                        if not ensure_len_match(mesh, other_key, op=self):
                                continue
                        for i in range(len(mesh.vertices)):
                                if mesh.vertices[i].select:
                                        other_offset = other_key.data[i].co - ref_key.data[i].co
                                        active_offset = active_key.data[i].co - ref_key.data[i].co
                                        other_key.data[i].co = ref_key.data[i].co + other_offset + active_offset
                
                for i in range(len(mesh.vertices)):
                        if mesh.vertices[i].select:
                                ref_key.data[i].co = active_key.data[i].co.copy()
                
                _bpy.ops.object.mode_set_with_submode(mode=&#39;EDIT&#39;, toggle=False, mesh_select_mode={&#39;VERT&#39;})
                
                return {&#39;FINISHED&#39;}


#
# Object-mode operators


def apply_active_to_basis(obj: &#39;Object&#39;, keep_reverted=True, op: &#39;Operator&#39; = None):
        &#34;&#34;&#34;
        **Applies positions of active Shape Key to Reference ShapeKey (Basis).**
        Positions (shapes) will be transferred from active Shape Key to Reference ShapeKey (Basis).
        Other Shape Keys keep their positions (shapes).
        If `keep_reverted` then old positions from Reference ShapeKey (Basis) will be transferred to active Shape Key,
        so active Shape Key act as reverted. ` (Reverted)` will be added to it&#39;s name.
        If not `keep_reverted` then active Shape Key will be deleted.
        
        Returns: True if succeeded, False otherwise.
        
        Available as operator `OperatorApplyActiveToBasis`.
        See also: `apply_active_to_all`, `OperatorApplySelectedInActiveToBasis`.
        &#34;&#34;&#34;
        # No context control
        mesh = obj.data  # type: Mesh
        active_key = obj.active_shape_key
        ref_key = mesh.shape_keys.reference_key
        
        match_active = ensure_len_match(mesh, active_key, op=op)
        match_ref = ensure_len_match(mesh, ref_key, op=op)
        if not match_active or not match_ref:
                return False
        
        for i in range(len(mesh.vertices)):
                v = ref_key.data[i].co.copy()
                ref_key.data[i].co = active_key.data[i].co.copy()
                active_key.data[i].co = v
        
        if keep_reverted:
                active_key.name += &#39; (Reverted)&#39;
        else:
                obj.active_shape_key_index = 0
                obj.shape_key_remove(active_key)
        return True


class OperatorApplyActiveToBasis(_KawaOperator):
        &#34;&#34;&#34;
        Operator of `apply_active_to_basis`.
        See also: `OperatorApplySelectedInActiveToBasis`.
        &#34;&#34;&#34;
        bl_idname = &#34;kawa.apply_active_shape_keys_to_basis&#34;
        bl_label = &#34;APPLY ACTIVE Shape Key to Basis&#34;
        bl_description = &#34;\n&#34;.join((
                &#34;Positions (shapes) will be transferred from active Shape Key to Reference ShapeKey (Basis).&#34;,
                &#34;Other Shape Keys keep their positions (shapes).&#34;,
        ))
        bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}
        
        keep_reverted: _bpy.props.BoolProperty(
                name=&#34;Keep Reverted Shape Key&#34;,
                default=True,
        )
        
        @classmethod
        def poll(cls, context: &#39;Context&#39;):
                obj = cls.get_active_obj(context)
                if not obj or obj.type != &#39;MESH&#39;:
                        return False  # Требуется активный меш-объект
                if not obj.active_shape_key or obj.active_shape_key_index == 0:
                        return False  # Требуется что бы был активный не первый шейпкей
                if context.mode != &#39;OBJECT&#39;:
                        return False  # Требуется режим OBJECT
                return True
        
        def invoke(self, context: &#39;Context&#39;, event):
                return context.window_manager.invoke_props_dialog(self)
        
        def execute(self, context: &#39;Context&#39;):
                return {&#39;FINISHED&#39;} if apply_active_to_basis(self.get_active_obj(context), keep_reverted=self.keep_reverted, op=self) else {&#39;CANCELLED&#39;}


def apply_active_to_all(obj: &#39;Object&#39;, keep_reverted=False, op: &#39;Operator&#39; = None):
        &#34;&#34;&#34;
        **Applies offsets of active Shape Key to every other shape key.**
        Same as `apply_active_to_basis`, but other Shape Keys will be also edited.
        It&#39;s like changing whole base mesh with all it&#39;s shape keys.
        If `keep_reverted` then old positions from Reference ShapeKey (Basis) will be moved to active Shape Key,
        so active Shape Key act as reverted. ` (Reverted)` will be added to it&#39;s name.
        If not `keep_reverted` then active Shape Key will be deleted.
        
        Returns: True if succeeded, False otherwise.
        
        Available as operator `OperatorApplyActiveToAll`.
        See also: `OperatorApplySelectedInActiveToAll`.
        &#34;&#34;&#34;
        # No context control
        mesh = obj.data  # type: Mesh
        active_key = obj.active_shape_key
        ref_key = mesh.shape_keys.reference_key
        
        match_active = ensure_len_match(mesh, active_key, op=op)
        match_ref = ensure_len_match(mesh, ref_key, op=op)
        if not match_active or not match_ref:
                return False
        
        for other_key in mesh.shape_keys.key_blocks:
                if other_key == active_key or other_key == ref_key:
                        continue
                if not ensure_len_match(mesh, other_key, op=op):
                        continue
                for i in range(len(mesh.vertices)):
                        other_offset = other_key.data[i].co - ref_key.data[i].co
                        active_offset = active_key.data[i].co - ref_key.data[i].co
                        other_key.data[i].co = ref_key.data[i].co + other_offset + active_offset
        
        for i in range(len(mesh.vertices)):
                v = ref_key.data[i].co.copy()
                ref_key.data[i].co = active_key.data[i].co.copy()
                active_key.data[i].co = v
        
        if keep_reverted:
                active_key.name += &#39; (Reverted)&#39;
        else:
                obj.active_shape_key_index = 0
                obj.shape_key_remove(active_key)
        return True


class OperatorApplyActiveToAll(_KawaOperator):
        &#34;&#34;&#34;
        Operator of `apply_active_to_all`.
        See also: `OperatorApplySelectedInActiveToAll`.
        &#34;&#34;&#34;
        bl_idname = &#34;kawa.apply_active_shape_keys_to_all&#34;
        bl_label = &#34;APPLY ACTIVE Shape Key to ALL Others&#34;
        bl_description = &#34;Same as {}, but other Shape Keys will be also edited.&#34;.format(
                repr(OperatorApplyActiveToBasis.bl_label))
        bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}
        
        keep_reverted: _bpy.props.BoolProperty(
                name=&#34;Keep Reverted Shape Key&#34;,
                default=False,
        )
        
        @classmethod
        def poll(cls, context: &#39;Context&#39;):
                obj = cls.get_active_obj(context)
                if not obj or obj.type != &#39;MESH&#39;:
                        return False  # Требуется активный меш-объект
                if not obj.active_shape_key or obj.active_shape_key_index == 0:
                        return False  # Требуется что бы был активный не первый шейпкей
                if context.mode != &#39;OBJECT&#39;:
                        return False  # Требуется режим OBJECT
                return True
        
        def invoke(self, context: &#39;Context&#39;, event):
                return context.window_manager.invoke_props_dialog(self)
        
        def execute(self, context: &#39;Context&#39;):
                return {&#39;FINISHED&#39;} if apply_active_to_all(self.get_active_obj(context), keep_reverted=self.keep_reverted, op=self) else {&#39;CANCELLED&#39;}


def cleanup_active(obj: &#39;Object&#39;, epsilon: &#39;float&#39;, op: &#39;Operator&#39; = None) -&gt; &#39;int&#39;:
        &#34;&#34;&#34;
        **Removes micro-offsets in active Shape Key.**
        If position of a vertex differs from position in Reference Shape Key (Basis) for `epsilon` or less,
        then it&#39;s position will be reverted (to be the same as in Reference Shape Key)
        
        Returns: number of changed vertices.
        
        Available as operator `OperatorCleanupActive`
        &#34;&#34;&#34;
        if not _obj_have_shapekeys(obj, n=2):
                return 0
        mesh = obj.data  # type: Mesh
        active_key = obj.active_shape_key
        ref_key = mesh.shape_keys.reference_key
        if active_key == ref_key:
                return 0
        
        match_active = ensure_len_match(mesh, active_key, op=op)
        match_ref = ensure_len_match(mesh, ref_key, op=op)
        if not match_active or not match_ref:
                return 0
        
        changed = 0
        for i in range(len(mesh.vertices)):
                if (ref_key.data[i].co - active_key.data[i].co).magnitude &lt;= epsilon:
                        active_key.data[i].co = ref_key.data[i].co.copy()
                        changed += 1
        
        return changed


class OperatorCleanupActive(_KawaOperator):
        &#34;&#34;&#34;
        Operator of `cleanup_active`
        &#34;&#34;&#34;
        bl_idname = &#34;kawa.cleanup_active_shape_key&#34;
        bl_label = &#34;Remove Mirco-offsets in ACTIVE Shape Key&#34;
        bl_description = &#34;\n&#34;.join((
                &#34;If position of a vertex differs from position in Reference Shape Key (Basis) for `epsilon` or less,&#34;,
                &#34;then it&#39;s position will be reverted (to be the same as in Reference Shape Key)&#34;,
        ))
        bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}
        
        epsilon: _bpy.props.FloatProperty(
                name=&#34;Epsilon&#34;,
                description=&#34;Threshold in local space&#34;,
                min=1e-07,
                default=1e-04,
                max=1,
                precision=6,
                unit=&#39;LENGTH&#39;
        )
        
        @classmethod
        def poll(cls, context: &#39;Context&#39;):
                obj = cls.get_active_obj(context)
                if not obj or obj.type != &#39;MESH&#39;:
                        return False  # Требуется активный меш-объект
                if not obj.active_shape_key or obj.active_shape_key_index == 0:
                        return False  # Требуется что бы был активный не первый шейпкей
                if context.mode != &#39;OBJECT&#39;:
                        return False  # Требуется режим OBJECT
                return True
        
        def invoke(self, context: &#39;Context&#39;, event):
                return context.window_manager.invoke_props_dialog(self)
        
        def execute(self, context: &#39;Context&#39;):
                changed = cleanup_active(self.get_active_obj(context), self.epsilon, op=self)
                _log.info(&#34;Cleaned {0} vertices.&#34;.format(changed), op=self)
                return {&#39;FINISHED&#39;} if changed &gt; 0 else {&#39;CANCELLED&#39;}


def cleanup_all(objs: &#39;Iterable[Object]&#39;, epsilon: float, op: &#39;Operator&#39; = None) -&gt; &#39;Tuple[int, int, int]&#39;:
        &#34;&#34;&#34;
        **Removes micro-offsets in all Shape Keys.**
        Same as `cleanup_active`, but for every shape key (except reference one) for every object.
        
        Returns: (number of changed vertices, number of changed shape keys, number of changed meshes).
        
        Available as operator `OperatorCleanupAll`
        &#34;&#34;&#34;
        objs = list(obj for obj in objs if _obj_have_shapekeys(obj, n=2))  # type: List[Object]
        meshes = set()
        vertices_changed, shapekeys_changed, meshes_changed = 0, 0, 0
        for obj in objs:
                mesh = obj.data  # type: Mesh
                if mesh in meshes:
                        continue  # Уже трогали
                meshes.add(mesh)
                last_shape_key_index = obj.active_shape_key_index
                try:
                        mesh_changed = False
                        for shape_key_index in range(1, len(mesh.shape_keys.key_blocks)):
                                obj.active_shape_key_index = shape_key_index
                                vc = cleanup_active(obj, epsilon, op=op)
                                if vc &gt; 0:
                                        vertices_changed += vc
                                        shapekeys_changed += 1
                                        mesh_changed = True
                        if mesh_changed:
                                meshes_changed += 1
                finally:
                        obj.active_shape_key_index = last_shape_key_index
        return vertices_changed, shapekeys_changed, meshes_changed


class OperatorCleanupAll(_KawaOperator):
        &#34;&#34;&#34;
        Operator of `cleanup_all`
        &#34;&#34;&#34;
        bl_idname = &#34;kawa.cleanup_all_shape_keys&#34;
        bl_label = &#34;Remove Mirco-offsets in ALL Shape Keys&#34;
        bl_description = &#34;Same as {}, but for every shape key (except reference one) for every object&#34;.format(
                repr(OperatorCleanupActive.bl_label))
        bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}
        
        epsilon: _bpy.props.FloatProperty(
                name=&#34;Epsilon&#34;,
                description=&#34;Threshold in local space&#34;,
                min=1e-07,
                default=1e-04,
                max=1,
                precision=6,
                unit=&#39;LENGTH&#39;
        )
        
        @classmethod
        def poll(cls, context: &#39;Context&#39;):
                if context.mode != &#39;OBJECT&#39;:
                        return False  # Требуется режим OBJECT
                if not any(True for obj in cls.get_selected_objs(context) if _obj_have_shapekeys(obj, n=2)):
                        return False  # Должны быть выбраны Меш-объекты c 2 или более шейпами
                return True
        
        def invoke(self, context: &#39;Context&#39;, event):
                return context.window_manager.invoke_props_dialog(self)
        
        def execute(self, context: &#39;Context&#39;):
                selected = list(self.get_selected_objs(context))
                if len(selected) &lt; 1:
                        _log.warning(&#34;No mesh-objects with multiple shape keys selected.&#34;, op=self)
                        return {&#39;CANCELLED&#39;}
                vertices_cleaned, shapekeys_cleaned, objects_cleaned = cleanup_all(selected, self.epsilon, op=self)
                _log.info(&#34;Cleaned {0} Vertices in {1} Shape Keys in {2} Meshes from micro-offsets (&lt;{3}).&#34;.format(
                        vertices_cleaned, shapekeys_cleaned, objects_cleaned, float(self.epsilon)), op=self)
                return {&#39;FINISHED&#39;} if vertices_cleaned &gt; 0 else {&#39;CANCELLED&#39;}


def remove_empty(objs: &#39;Iterable[Object]&#39;, epsilon: float, op: &#39;Operator&#39; = None) -&gt; &#39;Tuple[int, int]&#39;:
        &#34;&#34;&#34;
        **Removes empty Shape Keys from Mesh-objects.**
        Shape Key is empty, if positions of **every** vertex differ from Reference Shape Key (Basis) for `epsilon` or less.
        
        Returns: (number of removed Shape Keys, number of meshes changed)
        
        Available as operator `OperatorRemoveEmpty`
        &#34;&#34;&#34;
        objs = list(obj for obj in objs if _obj_have_shapekeys(obj, n=2))  # type: List[Object]
        removed_shapekeys, changed_meshes = 0, 0
        meshes = set()
        for obj in objs:
                mesh = obj.data  # type: Mesh
                if mesh in meshes:
                        continue  # Уже трогали
                meshes.add(mesh)
                key = mesh.shape_keys  # type: Key
                reference = key.reference_key
                empty_keys = set()  # type: Set[str]
                for shape_key in key.key_blocks:
                        if shape_key == reference:
                                continue  # Базис не удаялется
                        match1 = ensure_len_match(mesh, reference, op=op)
                        match2 = ensure_len_match(mesh, shape_key, op=op)
                        if not match1 or not match2:
                                continue
                        # Имеются ли различия между шейпами?
                        if not any((shape_key.data[i].co - reference.data[i].co).magnitude &gt; epsilon for i in range(len(mesh.vertices))):
                                empty_keys.add(shape_key.name)
                # _log.info(&#34;Found {0} empty shape keys in mesh {1}: {2}, removing...&#34;.format(len(empty_keys), repr(mesh), repr(empty_keys)), op=op)
                if len(empty_keys) &lt; 1:
                        continue
                for empty_key in empty_keys:
                        # На всякий случай удаляю по прямому пути, вдруг там что-то перестраивается в процессе удаления.
                        # Не спроста же Key-блоки можно редактировать только через Object-блоки
                        obj.shape_key_remove(obj.data.shape_keys.key_blocks[empty_key])
                removed_shapekeys += len(empty_keys)
                changed_meshes += 1
        return removed_shapekeys, changed_meshes


class OperatorRemoveEmpty(_KawaOperator):
        &#34;&#34;&#34;
        Operator of `remove_empty`.
        &#34;&#34;&#34;
        bl_idname = &#34;kawa.remove_empty_shape_keys&#34;
        bl_label = &#34;Remove Empty Shape Keys&#34;
        bl_description = &#34;\n&#34;.join((
                &#34;Shape Key is empty, if positions of EVERY vertex differ &#34;,
                &#34;from Reference Shape Key (Basis) for Epsilon or less.&#34;,
        ))
        bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}
        
        epsilon: _bpy.props.FloatProperty(
                name=&#34;Epsilon&#34;,
                description=&#34;Selection precision in local space&#34;,
                min=1e-07,
                default=1e-06,
                max=1,
                precision=6,
                unit=&#39;LENGTH&#39;
        )
        
        @classmethod
        def poll(cls, context: &#39;Context&#39;):
                if context.mode != &#39;OBJECT&#39;:
                        return False  # Требуется режим OBJECT
                if not any(True for obj in cls.get_selected_objs(context) if _obj_have_shapekeys(obj, n=2)):
                        return False  # Должны быть выбраны какие-то Меш-объекты
                return True
        
        def invoke(self, context: &#39;Context&#39;, event):
                return context.window_manager.invoke_props_dialog(self)
        
        def execute(self, context: &#39;Context&#39;):
                objs = self.get_selected_objs(context)
                removed_shapekeys, changed_meshes = remove_empty(objs, self.epsilon, op=self)
                _log.info(&#34;Total {0} shape keys removed from {1} Meshes.&#34;.format(removed_shapekeys, changed_meshes), op=self)
                return {&#39;FINISHED&#39;} if removed_shapekeys &gt; 0 else {&#39;CANCELLED&#39;}


OperatorApplySelectedInActiveToBasis.bl_description = \
        &#34;Same as {}, but only for selected vertices in edit-mode.&#34;.format(repr(OperatorApplyActiveToBasis.bl_label))
OperatorApplySelectedInActiveToAll.bl_description = \
        &#34;Same as {}, but only for selected vertices in edit-mode.&#34;.format(repr(OperatorApplyActiveToAll.bl_label))

classes = (
        # Edit-mode
        OperatorSelectVerticesAffectedByShapeKey,
                #
        OperatorRevertSelectedInActiveToBasis,
        OperatorRevertSelectedInAllToBasis,
                #
        OperatorApplySelectedInActiveToBasis,
        OperatorApplySelectedInActiveToAll,
                #
                # Object-mode
        OperatorApplyActiveToBasis,
        OperatorApplyActiveToAll,
                #
        OperatorCleanupActive,
        OperatorCleanupAll,
        OperatorRemoveEmpty,
)

__pdoc__ = dict()
_doc.process_blender_classes(__pdoc__, classes)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="kawa_scripts.shapekeys.apply_active_to_all"><code class="name flex">
<span>def <span class="ident">apply_active_to_all</span></span>(<span>obj: Object, keep_reverted=False, op: Operator = None)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>Applies offsets of active Shape Key to every other shape key.</strong>
Same as <code><a title="kawa_scripts.shapekeys.apply_active_to_basis" href="#kawa_scripts.shapekeys.apply_active_to_basis">apply_active_to_basis()</a></code>, but other Shape Keys will be also edited.
It's like changing whole base mesh with all it's shape keys.
If <code>keep_reverted</code> then old positions from Reference ShapeKey (Basis) will be moved to active Shape Key,
so active Shape Key act as reverted. <code> (Reverted)</code> will be added to it's name.
If not <code>keep_reverted</code> then active Shape Key will be deleted.</p>
<p>Returns: True if succeeded, False otherwise.</p>
<p>Available as operator <code><a title="kawa_scripts.shapekeys.OperatorApplyActiveToAll" href="#kawa_scripts.shapekeys.OperatorApplyActiveToAll">OperatorApplyActiveToAll</a></code>.
See also: <code><a title="kawa_scripts.shapekeys.OperatorApplySelectedInActiveToAll" href="#kawa_scripts.shapekeys.OperatorApplySelectedInActiveToAll">OperatorApplySelectedInActiveToAll</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_active_to_all(obj: &#39;Object&#39;, keep_reverted=False, op: &#39;Operator&#39; = None):
        &#34;&#34;&#34;
        **Applies offsets of active Shape Key to every other shape key.**
        Same as `apply_active_to_basis`, but other Shape Keys will be also edited.
        It&#39;s like changing whole base mesh with all it&#39;s shape keys.
        If `keep_reverted` then old positions from Reference ShapeKey (Basis) will be moved to active Shape Key,
        so active Shape Key act as reverted. ` (Reverted)` will be added to it&#39;s name.
        If not `keep_reverted` then active Shape Key will be deleted.
        
        Returns: True if succeeded, False otherwise.
        
        Available as operator `OperatorApplyActiveToAll`.
        See also: `OperatorApplySelectedInActiveToAll`.
        &#34;&#34;&#34;
        # No context control
        mesh = obj.data  # type: Mesh
        active_key = obj.active_shape_key
        ref_key = mesh.shape_keys.reference_key
        
        match_active = ensure_len_match(mesh, active_key, op=op)
        match_ref = ensure_len_match(mesh, ref_key, op=op)
        if not match_active or not match_ref:
                return False
        
        for other_key in mesh.shape_keys.key_blocks:
                if other_key == active_key or other_key == ref_key:
                        continue
                if not ensure_len_match(mesh, other_key, op=op):
                        continue
                for i in range(len(mesh.vertices)):
                        other_offset = other_key.data[i].co - ref_key.data[i].co
                        active_offset = active_key.data[i].co - ref_key.data[i].co
                        other_key.data[i].co = ref_key.data[i].co + other_offset + active_offset
        
        for i in range(len(mesh.vertices)):
                v = ref_key.data[i].co.copy()
                ref_key.data[i].co = active_key.data[i].co.copy()
                active_key.data[i].co = v
        
        if keep_reverted:
                active_key.name += &#39; (Reverted)&#39;
        else:
                obj.active_shape_key_index = 0
                obj.shape_key_remove(active_key)
        return True</code></pre>
</details>
</dd>
<dt id="kawa_scripts.shapekeys.apply_active_to_basis"><code class="name flex">
<span>def <span class="ident">apply_active_to_basis</span></span>(<span>obj: Object, keep_reverted=True, op: Operator = None)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>Applies positions of active Shape Key to Reference ShapeKey (Basis).</strong>
Positions (shapes) will be transferred from active Shape Key to Reference ShapeKey (Basis).
Other Shape Keys keep their positions (shapes).
If <code>keep_reverted</code> then old positions from Reference ShapeKey (Basis) will be transferred to active Shape Key,
so active Shape Key act as reverted. <code> (Reverted)</code> will be added to it's name.
If not <code>keep_reverted</code> then active Shape Key will be deleted.</p>
<p>Returns: True if succeeded, False otherwise.</p>
<p>Available as operator <code><a title="kawa_scripts.shapekeys.OperatorApplyActiveToBasis" href="#kawa_scripts.shapekeys.OperatorApplyActiveToBasis">OperatorApplyActiveToBasis</a></code>.
See also: <code><a title="kawa_scripts.shapekeys.apply_active_to_all" href="#kawa_scripts.shapekeys.apply_active_to_all">apply_active_to_all()</a></code>, <code><a title="kawa_scripts.shapekeys.OperatorApplySelectedInActiveToBasis" href="#kawa_scripts.shapekeys.OperatorApplySelectedInActiveToBasis">OperatorApplySelectedInActiveToBasis</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_active_to_basis(obj: &#39;Object&#39;, keep_reverted=True, op: &#39;Operator&#39; = None):
        &#34;&#34;&#34;
        **Applies positions of active Shape Key to Reference ShapeKey (Basis).**
        Positions (shapes) will be transferred from active Shape Key to Reference ShapeKey (Basis).
        Other Shape Keys keep their positions (shapes).
        If `keep_reverted` then old positions from Reference ShapeKey (Basis) will be transferred to active Shape Key,
        so active Shape Key act as reverted. ` (Reverted)` will be added to it&#39;s name.
        If not `keep_reverted` then active Shape Key will be deleted.
        
        Returns: True if succeeded, False otherwise.
        
        Available as operator `OperatorApplyActiveToBasis`.
        See also: `apply_active_to_all`, `OperatorApplySelectedInActiveToBasis`.
        &#34;&#34;&#34;
        # No context control
        mesh = obj.data  # type: Mesh
        active_key = obj.active_shape_key
        ref_key = mesh.shape_keys.reference_key
        
        match_active = ensure_len_match(mesh, active_key, op=op)
        match_ref = ensure_len_match(mesh, ref_key, op=op)
        if not match_active or not match_ref:
                return False
        
        for i in range(len(mesh.vertices)):
                v = ref_key.data[i].co.copy()
                ref_key.data[i].co = active_key.data[i].co.copy()
                active_key.data[i].co = v
        
        if keep_reverted:
                active_key.name += &#39; (Reverted)&#39;
        else:
                obj.active_shape_key_index = 0
                obj.shape_key_remove(active_key)
        return True</code></pre>
</details>
</dd>
<dt id="kawa_scripts.shapekeys.cleanup_active"><code class="name flex">
<span>def <span class="ident">cleanup_active</span></span>(<span>obj: Object, epsilon: float, op: Operator = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p><strong>Removes micro-offsets in active Shape Key.</strong>
If position of a vertex differs from position in Reference Shape Key (Basis) for <code>epsilon</code> or less,
then it's position will be reverted (to be the same as in Reference Shape Key)</p>
<p>Returns: number of changed vertices.</p>
<p>Available as operator <code><a title="kawa_scripts.shapekeys.OperatorCleanupActive" href="#kawa_scripts.shapekeys.OperatorCleanupActive">OperatorCleanupActive</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanup_active(obj: &#39;Object&#39;, epsilon: &#39;float&#39;, op: &#39;Operator&#39; = None) -&gt; &#39;int&#39;:
        &#34;&#34;&#34;
        **Removes micro-offsets in active Shape Key.**
        If position of a vertex differs from position in Reference Shape Key (Basis) for `epsilon` or less,
        then it&#39;s position will be reverted (to be the same as in Reference Shape Key)
        
        Returns: number of changed vertices.
        
        Available as operator `OperatorCleanupActive`
        &#34;&#34;&#34;
        if not _obj_have_shapekeys(obj, n=2):
                return 0
        mesh = obj.data  # type: Mesh
        active_key = obj.active_shape_key
        ref_key = mesh.shape_keys.reference_key
        if active_key == ref_key:
                return 0
        
        match_active = ensure_len_match(mesh, active_key, op=op)
        match_ref = ensure_len_match(mesh, ref_key, op=op)
        if not match_active or not match_ref:
                return 0
        
        changed = 0
        for i in range(len(mesh.vertices)):
                if (ref_key.data[i].co - active_key.data[i].co).magnitude &lt;= epsilon:
                        active_key.data[i].co = ref_key.data[i].co.copy()
                        changed += 1
        
        return changed</code></pre>
</details>
</dd>
<dt id="kawa_scripts.shapekeys.cleanup_all"><code class="name flex">
<span>def <span class="ident">cleanup_all</span></span>(<span>objs: Iterable[Object], epsilon: float, op: Operator = None) ‑> Tuple[int, int, int]</span>
</code></dt>
<dd>
<div class="desc"><p><strong>Removes micro-offsets in all Shape Keys.</strong>
Same as <code><a title="kawa_scripts.shapekeys.cleanup_active" href="#kawa_scripts.shapekeys.cleanup_active">cleanup_active()</a></code>, but for every shape key (except reference one) for every object.</p>
<p>Returns: (number of changed vertices, number of changed shape keys, number of changed meshes).</p>
<p>Available as operator <code><a title="kawa_scripts.shapekeys.OperatorCleanupAll" href="#kawa_scripts.shapekeys.OperatorCleanupAll">OperatorCleanupAll</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanup_all(objs: &#39;Iterable[Object]&#39;, epsilon: float, op: &#39;Operator&#39; = None) -&gt; &#39;Tuple[int, int, int]&#39;:
        &#34;&#34;&#34;
        **Removes micro-offsets in all Shape Keys.**
        Same as `cleanup_active`, but for every shape key (except reference one) for every object.
        
        Returns: (number of changed vertices, number of changed shape keys, number of changed meshes).
        
        Available as operator `OperatorCleanupAll`
        &#34;&#34;&#34;
        objs = list(obj for obj in objs if _obj_have_shapekeys(obj, n=2))  # type: List[Object]
        meshes = set()
        vertices_changed, shapekeys_changed, meshes_changed = 0, 0, 0
        for obj in objs:
                mesh = obj.data  # type: Mesh
                if mesh in meshes:
                        continue  # Уже трогали
                meshes.add(mesh)
                last_shape_key_index = obj.active_shape_key_index
                try:
                        mesh_changed = False
                        for shape_key_index in range(1, len(mesh.shape_keys.key_blocks)):
                                obj.active_shape_key_index = shape_key_index
                                vc = cleanup_active(obj, epsilon, op=op)
                                if vc &gt; 0:
                                        vertices_changed += vc
                                        shapekeys_changed += 1
                                        mesh_changed = True
                        if mesh_changed:
                                meshes_changed += 1
                finally:
                        obj.active_shape_key_index = last_shape_key_index
        return vertices_changed, shapekeys_changed, meshes_changed</code></pre>
</details>
</dd>
<dt id="kawa_scripts.shapekeys.ensure_len_match"><code class="name flex">
<span>def <span class="ident">ensure_len_match</span></span>(<span>mesh: Mesh, shape_key: ShapeKey, op: Operator = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure <code>len(mesh.vertices) == len(shape_key.data)</code>. Helps to detect corrupted Mesh/Key datablocks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensure_len_match(mesh: &#39;Mesh&#39;, shape_key: &#39;ShapeKey&#39;, op: &#39;Operator&#39; = None):
        &#34;&#34;&#34;
        Ensure `len(mesh.vertices) == len(shape_key.data)`. Helps to detect corrupted Mesh/Key datablocks.
        &#34;&#34;&#34;
        len_vts = len(mesh.vertices)
        len_skd = len(shape_key.data)
        if len_vts == len_skd:
                return True
        _log.error(&#34;Size of {0} ({1}) and size of {2} ({3}) does not match! Is shape key corrupted?&#34;
                .format(repr(mesh.vertices), len_vts, repr(shape_key.data), len_skd), op=op)
        return False</code></pre>
</details>
</dd>
<dt id="kawa_scripts.shapekeys.remove_empty"><code class="name flex">
<span>def <span class="ident">remove_empty</span></span>(<span>objs: Iterable[Object], epsilon: float, op: Operator = None) ‑> Tuple[int, int]</span>
</code></dt>
<dd>
<div class="desc"><p><strong>Removes empty Shape Keys from Mesh-objects.</strong>
Shape Key is empty, if positions of <strong>every</strong> vertex differ from Reference Shape Key (Basis) for <code>epsilon</code> or less.</p>
<p>Returns: (number of removed Shape Keys, number of meshes changed)</p>
<p>Available as operator <code><a title="kawa_scripts.shapekeys.OperatorRemoveEmpty" href="#kawa_scripts.shapekeys.OperatorRemoveEmpty">OperatorRemoveEmpty</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_empty(objs: &#39;Iterable[Object]&#39;, epsilon: float, op: &#39;Operator&#39; = None) -&gt; &#39;Tuple[int, int]&#39;:
        &#34;&#34;&#34;
        **Removes empty Shape Keys from Mesh-objects.**
        Shape Key is empty, if positions of **every** vertex differ from Reference Shape Key (Basis) for `epsilon` or less.
        
        Returns: (number of removed Shape Keys, number of meshes changed)
        
        Available as operator `OperatorRemoveEmpty`
        &#34;&#34;&#34;
        objs = list(obj for obj in objs if _obj_have_shapekeys(obj, n=2))  # type: List[Object]
        removed_shapekeys, changed_meshes = 0, 0
        meshes = set()
        for obj in objs:
                mesh = obj.data  # type: Mesh
                if mesh in meshes:
                        continue  # Уже трогали
                meshes.add(mesh)
                key = mesh.shape_keys  # type: Key
                reference = key.reference_key
                empty_keys = set()  # type: Set[str]
                for shape_key in key.key_blocks:
                        if shape_key == reference:
                                continue  # Базис не удаялется
                        match1 = ensure_len_match(mesh, reference, op=op)
                        match2 = ensure_len_match(mesh, shape_key, op=op)
                        if not match1 or not match2:
                                continue
                        # Имеются ли различия между шейпами?
                        if not any((shape_key.data[i].co - reference.data[i].co).magnitude &gt; epsilon for i in range(len(mesh.vertices))):
                                empty_keys.add(shape_key.name)
                # _log.info(&#34;Found {0} empty shape keys in mesh {1}: {2}, removing...&#34;.format(len(empty_keys), repr(mesh), repr(empty_keys)), op=op)
                if len(empty_keys) &lt; 1:
                        continue
                for empty_key in empty_keys:
                        # На всякий случай удаляю по прямому пути, вдруг там что-то перестраивается в процессе удаления.
                        # Не спроста же Key-блоки можно редактировать только через Object-блоки
                        obj.shape_key_remove(obj.data.shape_keys.key_blocks[empty_key])
                removed_shapekeys += len(empty_keys)
                changed_meshes += 1
        return removed_shapekeys, changed_meshes</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="kawa_scripts.shapekeys.OperatorApplyActiveToAll"><code class="flex name class">
<span>class <span class="ident">OperatorApplyActiveToAll</span></span>
</code></dt>
<dd>
<div class="desc"><p>Operator of <code><a title="kawa_scripts.shapekeys.apply_active_to_all" href="#kawa_scripts.shapekeys.apply_active_to_all">apply_active_to_all()</a></code>.
See also: <code><a title="kawa_scripts.shapekeys.OperatorApplySelectedInActiveToAll" href="#kawa_scripts.shapekeys.OperatorApplySelectedInActiveToAll">OperatorApplySelectedInActiveToAll</a></code>.</p>
<p>ID name: <code>kawa.apply_active_shape_keys_to_all</code>.</p>
<p>Label: <code>APPLY ACTIVE Shape Key to ALL Others</code>.</p>
<p>Description: <code>Same as 'APPLY ACTIVE Shape Key to Basis', but other Shape Keys will be also edited.</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OperatorApplyActiveToAll(_KawaOperator):
        &#34;&#34;&#34;
        Operator of `apply_active_to_all`.
        See also: `OperatorApplySelectedInActiveToAll`.
        &#34;&#34;&#34;
        bl_idname = &#34;kawa.apply_active_shape_keys_to_all&#34;
        bl_label = &#34;APPLY ACTIVE Shape Key to ALL Others&#34;
        bl_description = &#34;Same as {}, but other Shape Keys will be also edited.&#34;.format(
                repr(OperatorApplyActiveToBasis.bl_label))
        bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}
        
        keep_reverted: _bpy.props.BoolProperty(
                name=&#34;Keep Reverted Shape Key&#34;,
                default=False,
        )
        
        @classmethod
        def poll(cls, context: &#39;Context&#39;):
                obj = cls.get_active_obj(context)
                if not obj or obj.type != &#39;MESH&#39;:
                        return False  # Требуется активный меш-объект
                if not obj.active_shape_key or obj.active_shape_key_index == 0:
                        return False  # Требуется что бы был активный не первый шейпкей
                if context.mode != &#39;OBJECT&#39;:
                        return False  # Требуется режим OBJECT
                return True
        
        def invoke(self, context: &#39;Context&#39;, event):
                return context.window_manager.invoke_props_dialog(self)
        
        def execute(self, context: &#39;Context&#39;):
                return {&#39;FINISHED&#39;} if apply_active_to_all(self.get_active_obj(context), keep_reverted=self.keep_reverted, op=self) else {&#39;CANCELLED&#39;}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>kawa_scripts._internals.KawaOperator</li>
<li>bpy.types.Operator</li>
<li>bpy.types.bpy_struct</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kawa_scripts.shapekeys.OperatorApplyActiveToAll.keep_reverted"><code class="name">var <span class="ident">keep_reverted</span> : None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="kawa_scripts.shapekeys.OperatorApplyActiveToBasis"><code class="flex name class">
<span>class <span class="ident">OperatorApplyActiveToBasis</span></span>
</code></dt>
<dd>
<div class="desc"><p>Operator of <code><a title="kawa_scripts.shapekeys.apply_active_to_basis" href="#kawa_scripts.shapekeys.apply_active_to_basis">apply_active_to_basis()</a></code>.
See also: <code><a title="kawa_scripts.shapekeys.OperatorApplySelectedInActiveToBasis" href="#kawa_scripts.shapekeys.OperatorApplySelectedInActiveToBasis">OperatorApplySelectedInActiveToBasis</a></code>.</p>
<p>ID name: <code>kawa.apply_active_shape_keys_to_basis</code>.</p>
<p>Label: <code>APPLY ACTIVE Shape Key to Basis</code>.</p>
<p>Description: <code>Positions (shapes) will be transferred from active Shape Key to Reference ShapeKey (Basis).
Other Shape Keys keep their positions (shapes).</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OperatorApplyActiveToBasis(_KawaOperator):
        &#34;&#34;&#34;
        Operator of `apply_active_to_basis`.
        See also: `OperatorApplySelectedInActiveToBasis`.
        &#34;&#34;&#34;
        bl_idname = &#34;kawa.apply_active_shape_keys_to_basis&#34;
        bl_label = &#34;APPLY ACTIVE Shape Key to Basis&#34;
        bl_description = &#34;\n&#34;.join((
                &#34;Positions (shapes) will be transferred from active Shape Key to Reference ShapeKey (Basis).&#34;,
                &#34;Other Shape Keys keep their positions (shapes).&#34;,
        ))
        bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}
        
        keep_reverted: _bpy.props.BoolProperty(
                name=&#34;Keep Reverted Shape Key&#34;,
                default=True,
        )
        
        @classmethod
        def poll(cls, context: &#39;Context&#39;):
                obj = cls.get_active_obj(context)
                if not obj or obj.type != &#39;MESH&#39;:
                        return False  # Требуется активный меш-объект
                if not obj.active_shape_key or obj.active_shape_key_index == 0:
                        return False  # Требуется что бы был активный не первый шейпкей
                if context.mode != &#39;OBJECT&#39;:
                        return False  # Требуется режим OBJECT
                return True
        
        def invoke(self, context: &#39;Context&#39;, event):
                return context.window_manager.invoke_props_dialog(self)
        
        def execute(self, context: &#39;Context&#39;):
                return {&#39;FINISHED&#39;} if apply_active_to_basis(self.get_active_obj(context), keep_reverted=self.keep_reverted, op=self) else {&#39;CANCELLED&#39;}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>kawa_scripts._internals.KawaOperator</li>
<li>bpy.types.Operator</li>
<li>bpy.types.bpy_struct</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kawa_scripts.shapekeys.OperatorApplyActiveToBasis.keep_reverted"><code class="name">var <span class="ident">keep_reverted</span> : None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="kawa_scripts.shapekeys.OperatorApplySelectedInActiveToAll"><code class="flex name class">
<span>class <span class="ident">OperatorApplySelectedInActiveToAll</span></span>
</code></dt>
<dd>
<div class="desc"><p>Same as <code><a title="kawa_scripts.shapekeys.OperatorApplyActiveToAll" href="#kawa_scripts.shapekeys.OperatorApplyActiveToAll">OperatorApplyActiveToAll</a></code>, but only for selected vertices in edit-mode.
See also: <code><a title="kawa_scripts.shapekeys.apply_active_to_all" href="#kawa_scripts.shapekeys.apply_active_to_all">apply_active_to_all()</a></code>.</p>
<p>ID name: <code>kawa.apply_selected_shape_keys_in_active_to_all</code>.</p>
<p>Label: <code>APPLY SELECTED Vertices in ACTIVE Shape Key to ALL Others</code>.</p>
<p>Description: <code>Same as 'APPLY ACTIVE Shape Key to ALL Others', but only for selected vertices in edit-mode.</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OperatorApplySelectedInActiveToAll(_KawaOperator):
        &#34;&#34;&#34;
        Same as `OperatorApplyActiveToAll`, but only for selected vertices in edit-mode.
        See also: `apply_active_to_all`.
        &#34;&#34;&#34;
        bl_idname = &#34;kawa.apply_selected_shape_keys_in_active_to_all&#34;
        bl_label = &#34;APPLY SELECTED Vertices in ACTIVE Shape Key to ALL Others&#34;
        # bl_description at the end of file.
        bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}
        
        @classmethod
        def poll(cls, context: &#39;Context&#39;):
                obj = cls.get_active_obj(context)
                if not obj or obj.type != &#39;MESH&#39;:
                        return False  # Требуется активный меш-объект
                if not obj.active_shape_key or obj.active_shape_key_index == 0:
                        return False  # Требуется что бы был активный не первый шейпкей
                if context.mode != &#39;EDIT_MESH&#39;:
                        return False  # Требуется режим  EDIT_MESH
                return True
        
        def execute(self, context: &#39;Context&#39;):
                obj = self.get_active_obj(context)
                # Рофл в том, что операции над мешью надо проводить вне эдит-мода
                _bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;, toggle=False)
                mesh = obj.data  # type: Mesh
                active_key = obj.active_shape_key
                ref_key = mesh.shape_keys.reference_key
                
                match_active = ensure_len_match(mesh, active_key, op=self)
                match_ref = ensure_len_match(mesh, ref_key, op=self)
                if not match_active or not match_ref:
                        return {&#39;CANCELLED&#39;}
                
                _mesh_selection_to_vertices(mesh)
                
                for other_key in mesh.shape_keys.key_blocks:
                        if other_key == active_key or other_key == ref_key:
                                continue
                        if not ensure_len_match(mesh, other_key, op=self):
                                continue
                        for i in range(len(mesh.vertices)):
                                if mesh.vertices[i].select:
                                        other_offset = other_key.data[i].co - ref_key.data[i].co
                                        active_offset = active_key.data[i].co - ref_key.data[i].co
                                        other_key.data[i].co = ref_key.data[i].co + other_offset + active_offset
                
                for i in range(len(mesh.vertices)):
                        if mesh.vertices[i].select:
                                ref_key.data[i].co = active_key.data[i].co.copy()
                
                _bpy.ops.object.mode_set_with_submode(mode=&#39;EDIT&#39;, toggle=False, mesh_select_mode={&#39;VERT&#39;})
                
                return {&#39;FINISHED&#39;}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>kawa_scripts._internals.KawaOperator</li>
<li>bpy.types.Operator</li>
<li>bpy.types.bpy_struct</li>
</ul>
</dd>
<dt id="kawa_scripts.shapekeys.OperatorApplySelectedInActiveToBasis"><code class="flex name class">
<span>class <span class="ident">OperatorApplySelectedInActiveToBasis</span></span>
</code></dt>
<dd>
<div class="desc"><p>Same as <code><a title="kawa_scripts.shapekeys.OperatorApplyActiveToBasis" href="#kawa_scripts.shapekeys.OperatorApplyActiveToBasis">OperatorApplyActiveToBasis</a></code>, but only for selected vertices in edit-mode.
See also: <code><a title="kawa_scripts.shapekeys.apply_active_to_basis" href="#kawa_scripts.shapekeys.apply_active_to_basis">apply_active_to_basis()</a></code>.</p>
<p>ID name: <code>kawa.apply_selected_shape_keys_in_active_to_basis</code>.</p>
<p>Label: <code>APPLY SELECTED Vertices in ACTIVE Shape Key to Basis</code>.</p>
<p>Description: <code>Same as 'APPLY ACTIVE Shape Key to Basis', but only for selected vertices in edit-mode.</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OperatorApplySelectedInActiveToBasis(_KawaOperator):
        &#34;&#34;&#34;
        Same as `OperatorApplyActiveToBasis`, but only for selected vertices in edit-mode.
        See also: `apply_active_to_basis`.
        &#34;&#34;&#34;
        bl_idname = &#34;kawa.apply_selected_shape_keys_in_active_to_basis&#34;
        bl_label = &#34;APPLY SELECTED Vertices in ACTIVE Shape Key to Basis&#34;
        # bl_description at the end of file.
        bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}
        
        @classmethod
        def poll(cls, context: &#39;Context&#39;):
                obj = cls.get_active_obj(context)
                if not obj or obj.type != &#39;MESH&#39;:
                        return False  # Требуется активный меш-объект
                if not obj.active_shape_key or obj.active_shape_key_index == 0:
                        return False  # Требуется что бы был активный не первый шейпкей
                if context.mode != &#39;EDIT_MESH&#39;:
                        return False  # Требуется режим  EDIT_MESH
                return True
        
        def execute(self, context: &#39;Context&#39;):
                obj = self.get_active_obj(context)
                # Рофл в том, что операции над мешью надо проводить вне эдит-мода
                _bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;, toggle=False)
                mesh = obj.data  # type: Mesh
                active_key = obj.active_shape_key
                ref_key = mesh.shape_keys.reference_key
                
                match_active = ensure_len_match(mesh, active_key, op=self)
                match_ref = ensure_len_match(mesh, ref_key, op=self)
                if not match_active or not match_ref:
                        return {&#39;CANCELLED&#39;}
                
                _mesh_selection_to_vertices(mesh)
                
                for i in range(len(mesh.vertices)):
                        if mesh.vertices[i].select:
                                ref_key.data[i].co = active_key.data[i].co.copy()
                
                _bpy.ops.object.mode_set_with_submode(mode=&#39;EDIT&#39;, toggle=False, mesh_select_mode={&#39;VERT&#39;})
                
                return {&#39;FINISHED&#39;}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>kawa_scripts._internals.KawaOperator</li>
<li>bpy.types.Operator</li>
<li>bpy.types.bpy_struct</li>
</ul>
</dd>
<dt id="kawa_scripts.shapekeys.OperatorCleanupActive"><code class="flex name class">
<span>class <span class="ident">OperatorCleanupActive</span></span>
</code></dt>
<dd>
<div class="desc"><p>Operator of <code><a title="kawa_scripts.shapekeys.cleanup_active" href="#kawa_scripts.shapekeys.cleanup_active">cleanup_active()</a></code></p>
<p>ID name: <code>kawa.cleanup_active_shape_key</code>.</p>
<p>Label: <code>Remove Mirco-offsets in ACTIVE Shape Key</code>.</p>
<p>Description: <code>If position of a vertex differs from position in Reference Shape Key (Basis) for </code>epsilon<code>or less,
then it's position will be reverted (to be the same as in Reference Shape Key)</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OperatorCleanupActive(_KawaOperator):
        &#34;&#34;&#34;
        Operator of `cleanup_active`
        &#34;&#34;&#34;
        bl_idname = &#34;kawa.cleanup_active_shape_key&#34;
        bl_label = &#34;Remove Mirco-offsets in ACTIVE Shape Key&#34;
        bl_description = &#34;\n&#34;.join((
                &#34;If position of a vertex differs from position in Reference Shape Key (Basis) for `epsilon` or less,&#34;,
                &#34;then it&#39;s position will be reverted (to be the same as in Reference Shape Key)&#34;,
        ))
        bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}
        
        epsilon: _bpy.props.FloatProperty(
                name=&#34;Epsilon&#34;,
                description=&#34;Threshold in local space&#34;,
                min=1e-07,
                default=1e-04,
                max=1,
                precision=6,
                unit=&#39;LENGTH&#39;
        )
        
        @classmethod
        def poll(cls, context: &#39;Context&#39;):
                obj = cls.get_active_obj(context)
                if not obj or obj.type != &#39;MESH&#39;:
                        return False  # Требуется активный меш-объект
                if not obj.active_shape_key or obj.active_shape_key_index == 0:
                        return False  # Требуется что бы был активный не первый шейпкей
                if context.mode != &#39;OBJECT&#39;:
                        return False  # Требуется режим OBJECT
                return True
        
        def invoke(self, context: &#39;Context&#39;, event):
                return context.window_manager.invoke_props_dialog(self)
        
        def execute(self, context: &#39;Context&#39;):
                changed = cleanup_active(self.get_active_obj(context), self.epsilon, op=self)
                _log.info(&#34;Cleaned {0} vertices.&#34;.format(changed), op=self)
                return {&#39;FINISHED&#39;} if changed &gt; 0 else {&#39;CANCELLED&#39;}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>kawa_scripts._internals.KawaOperator</li>
<li>bpy.types.Operator</li>
<li>bpy.types.bpy_struct</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kawa_scripts.shapekeys.OperatorCleanupActive.epsilon"><code class="name">var <span class="ident">epsilon</span> : None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="kawa_scripts.shapekeys.OperatorCleanupAll"><code class="flex name class">
<span>class <span class="ident">OperatorCleanupAll</span></span>
</code></dt>
<dd>
<div class="desc"><p>Operator of <code><a title="kawa_scripts.shapekeys.cleanup_all" href="#kawa_scripts.shapekeys.cleanup_all">cleanup_all()</a></code></p>
<p>ID name: <code>kawa.cleanup_all_shape_keys</code>.</p>
<p>Label: <code>Remove Mirco-offsets in ALL Shape Keys</code>.</p>
<p>Description: <code>Same as 'Remove Mirco-offsets in ACTIVE Shape Key', but for every shape key (except reference one) for every object</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OperatorCleanupAll(_KawaOperator):
        &#34;&#34;&#34;
        Operator of `cleanup_all`
        &#34;&#34;&#34;
        bl_idname = &#34;kawa.cleanup_all_shape_keys&#34;
        bl_label = &#34;Remove Mirco-offsets in ALL Shape Keys&#34;
        bl_description = &#34;Same as {}, but for every shape key (except reference one) for every object&#34;.format(
                repr(OperatorCleanupActive.bl_label))
        bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}
        
        epsilon: _bpy.props.FloatProperty(
                name=&#34;Epsilon&#34;,
                description=&#34;Threshold in local space&#34;,
                min=1e-07,
                default=1e-04,
                max=1,
                precision=6,
                unit=&#39;LENGTH&#39;
        )
        
        @classmethod
        def poll(cls, context: &#39;Context&#39;):
                if context.mode != &#39;OBJECT&#39;:
                        return False  # Требуется режим OBJECT
                if not any(True for obj in cls.get_selected_objs(context) if _obj_have_shapekeys(obj, n=2)):
                        return False  # Должны быть выбраны Меш-объекты c 2 или более шейпами
                return True
        
        def invoke(self, context: &#39;Context&#39;, event):
                return context.window_manager.invoke_props_dialog(self)
        
        def execute(self, context: &#39;Context&#39;):
                selected = list(self.get_selected_objs(context))
                if len(selected) &lt; 1:
                        _log.warning(&#34;No mesh-objects with multiple shape keys selected.&#34;, op=self)
                        return {&#39;CANCELLED&#39;}
                vertices_cleaned, shapekeys_cleaned, objects_cleaned = cleanup_all(selected, self.epsilon, op=self)
                _log.info(&#34;Cleaned {0} Vertices in {1} Shape Keys in {2} Meshes from micro-offsets (&lt;{3}).&#34;.format(
                        vertices_cleaned, shapekeys_cleaned, objects_cleaned, float(self.epsilon)), op=self)
                return {&#39;FINISHED&#39;} if vertices_cleaned &gt; 0 else {&#39;CANCELLED&#39;}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>kawa_scripts._internals.KawaOperator</li>
<li>bpy.types.Operator</li>
<li>bpy.types.bpy_struct</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kawa_scripts.shapekeys.OperatorCleanupAll.epsilon"><code class="name">var <span class="ident">epsilon</span> : None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="kawa_scripts.shapekeys.OperatorRemoveEmpty"><code class="flex name class">
<span>class <span class="ident">OperatorRemoveEmpty</span></span>
</code></dt>
<dd>
<div class="desc"><p>Operator of <code><a title="kawa_scripts.shapekeys.remove_empty" href="#kawa_scripts.shapekeys.remove_empty">remove_empty()</a></code>.</p>
<p>ID name: <code>kawa.remove_empty_shape_keys</code>.</p>
<p>Label: <code>Remove Empty Shape Keys</code>.</p>
<p>Description: <code>Shape Key is empty, if positions of EVERY vertex differ
from Reference Shape Key (Basis) for Epsilon or less.</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OperatorRemoveEmpty(_KawaOperator):
        &#34;&#34;&#34;
        Operator of `remove_empty`.
        &#34;&#34;&#34;
        bl_idname = &#34;kawa.remove_empty_shape_keys&#34;
        bl_label = &#34;Remove Empty Shape Keys&#34;
        bl_description = &#34;\n&#34;.join((
                &#34;Shape Key is empty, if positions of EVERY vertex differ &#34;,
                &#34;from Reference Shape Key (Basis) for Epsilon or less.&#34;,
        ))
        bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}
        
        epsilon: _bpy.props.FloatProperty(
                name=&#34;Epsilon&#34;,
                description=&#34;Selection precision in local space&#34;,
                min=1e-07,
                default=1e-06,
                max=1,
                precision=6,
                unit=&#39;LENGTH&#39;
        )
        
        @classmethod
        def poll(cls, context: &#39;Context&#39;):
                if context.mode != &#39;OBJECT&#39;:
                        return False  # Требуется режим OBJECT
                if not any(True for obj in cls.get_selected_objs(context) if _obj_have_shapekeys(obj, n=2)):
                        return False  # Должны быть выбраны какие-то Меш-объекты
                return True
        
        def invoke(self, context: &#39;Context&#39;, event):
                return context.window_manager.invoke_props_dialog(self)
        
        def execute(self, context: &#39;Context&#39;):
                objs = self.get_selected_objs(context)
                removed_shapekeys, changed_meshes = remove_empty(objs, self.epsilon, op=self)
                _log.info(&#34;Total {0} shape keys removed from {1} Meshes.&#34;.format(removed_shapekeys, changed_meshes), op=self)
                return {&#39;FINISHED&#39;} if removed_shapekeys &gt; 0 else {&#39;CANCELLED&#39;}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>kawa_scripts._internals.KawaOperator</li>
<li>bpy.types.Operator</li>
<li>bpy.types.bpy_struct</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kawa_scripts.shapekeys.OperatorRemoveEmpty.epsilon"><code class="name">var <span class="ident">epsilon</span> : None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="kawa_scripts.shapekeys.OperatorRevertSelectedInActiveToBasis"><code class="flex name class">
<span>class <span class="ident">OperatorRevertSelectedInActiveToBasis</span></span>
</code></dt>
<dd>
<div class="desc"><p><strong>Revert selected vertices in edit-mode to Reference Shape Key (Basis) in active Shape Key.</strong></p>
<p>ID name: <code>kawa.revert_selected_shape_keys_in_active_to_basis</code>.</p>
<p>Label: <code>REVERT SELECTED Vertices in ACTIVE Shape Key to BASIS</code>.</p>
<p>Description: <code>Revert selected vertices in edit-mode to Reference Shape Key (Basis) in active Shape Key.</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OperatorRevertSelectedInActiveToBasis(_KawaOperator):
        &#34;&#34;&#34;
        **Revert selected vertices in edit-mode to Reference Shape Key (Basis) in active Shape Key.**
        &#34;&#34;&#34;
        bl_idname = &#34;kawa.revert_selected_shape_keys_in_active_to_basis&#34;
        bl_label = &#34;REVERT SELECTED Vertices in ACTIVE Shape Key to BASIS&#34;
        bl_description = &#34;Revert selected vertices in edit-mode to Reference Shape Key (Basis) in active Shape Key.&#34;
        bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}
        
        @classmethod
        def poll(cls, context: &#39;Context&#39;):
                obj = cls.get_active_obj(context)
                if not obj or obj.type != &#39;MESH&#39;:
                        return False  # Требуется активный меш-объект
                if not obj.active_shape_key or obj.active_shape_key_index == 0:
                        return False  # Требуется что бы был активный не первый шейпкей
                if context.mode != &#39;EDIT_MESH&#39;:
                        return False  # Требуется режим  EDIT_MESH
                return True
        
        def execute(self, context: &#39;Context&#39;):
                obj = self.get_active_obj(context)
                # Рофл в том, что операции над мешью надо проводить вне эдит-мода
                _bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;, toggle=False)
                mesh = obj.data  # type: Mesh
                shape_key = obj.active_shape_key
                reference = mesh.shape_keys.reference_key
                
                match_skd = ensure_len_match(mesh, shape_key, op=self)
                match_ref = ensure_len_match(mesh, reference, op=self)
                if not match_skd or not match_ref:
                        return {&#39;CANCELLED&#39;}
                
                _mesh_selection_to_vertices(mesh)
                
                for i in range(len(mesh.vertices)):
                        if mesh.vertices[i].select:
                                shape_key.data[i].co = reference.data[i].co.copy()
                
                _bpy.ops.object.mode_set_with_submode(mode=&#39;EDIT&#39;, toggle=False, mesh_select_mode={&#39;VERT&#39;})
                
                return {&#39;FINISHED&#39;}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>kawa_scripts._internals.KawaOperator</li>
<li>bpy.types.Operator</li>
<li>bpy.types.bpy_struct</li>
</ul>
</dd>
<dt id="kawa_scripts.shapekeys.OperatorRevertSelectedInAllToBasis"><code class="flex name class">
<span>class <span class="ident">OperatorRevertSelectedInAllToBasis</span></span>
</code></dt>
<dd>
<div class="desc"><p><strong>Revert selected vertices in edit-mode to Reference Shape Key (Basis) in every Shape Key.</strong></p>
<p>ID name: <code>kawa.revert_selected_shape_keys_in_all_to_basis</code>.</p>
<p>Label: <code>REVERT SELECTED Vertices in ALL Shape Keys to BASIS</code>.</p>
<p>Description: <code>Revert selected vertices in edit-mode to Reference Shape Key (Basis) in every Shape Key.</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OperatorRevertSelectedInAllToBasis(_KawaOperator):
        &#34;&#34;&#34;
        **Revert selected vertices in edit-mode to Reference Shape Key (Basis) in every Shape Key.**
        &#34;&#34;&#34;
        bl_idname = &#34;kawa.revert_selected_shape_keys_in_all_to_basis&#34;
        bl_label = &#34;REVERT SELECTED Vertices in ALL Shape Keys to BASIS&#34;
        bl_description = &#34;Revert selected vertices in edit-mode to Reference Shape Key (Basis) in every Shape Key.&#34;
        bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}
        
        @classmethod
        def poll(cls, context: &#39;Context&#39;):
                obj = cls.get_active_obj(context)
                if not obj or obj.type != &#39;MESH&#39;:
                        return False  # Требуется активный меш-объект
                data = obj.data  # type: Mesh
                if data.shape_keys is None or len(data.shape_keys.key_blocks) &lt; 2:
                        return False  # Требуется что бы было 2 или более шейпкея
                if context.mode != &#39;EDIT_MESH&#39;:
                        return False  # Требуется режим  EDIT_MESH
                return True
        
        def execute(self, context: &#39;Context&#39;):
                obj = self.get_active_obj(context)
                # Рофл в том, что операции над мешью надо проводить вне эдит-мода
                _bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;, toggle=False)
                mesh = obj.data  # type: Mesh
                reference = mesh.shape_keys.reference_key
                
                if not ensure_len_match(mesh, reference, op=self):
                        return {&#39;CANCELLED&#39;}
                
                _mesh_selection_to_vertices(mesh)
                
                for shape_key in mesh.shape_keys.key_blocks:
                        if shape_key == reference:
                                continue
                        if not ensure_len_match(mesh, shape_key, op=self):
                                continue
                        for i in range(len(mesh.vertices)):
                                if mesh.vertices[i].select:
                                        shape_key.data[i].co = reference.data[i].co.copy()
                
                _bpy.ops.object.mode_set_with_submode(mode=&#39;EDIT&#39;, toggle=False, mesh_select_mode={&#39;VERT&#39;})
                
                return {&#39;FINISHED&#39;}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>kawa_scripts._internals.KawaOperator</li>
<li>bpy.types.Operator</li>
<li>bpy.types.bpy_struct</li>
</ul>
</dd>
<dt id="kawa_scripts.shapekeys.OperatorSelectVerticesAffectedByShapeKey"><code class="flex name class">
<span>class <span class="ident">OperatorSelectVerticesAffectedByShapeKey</span></span>
</code></dt>
<dd>
<div class="desc"><p><strong>Select Vertices Affected by Active Shape Key.</strong></p>
<p>ID name: <code>kawa.select_vertices_affected_by_shape_key</code>.</p>
<p>Label: <code>Select Vertices Affected by Active Shape Key</code>.</p>
<p>Description: <code>Select Vertices Affected by Active Shape Key.</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OperatorSelectVerticesAffectedByShapeKey(_KawaOperator):
        &#34;&#34;&#34;
        **Select Vertices Affected by Active Shape Key.**
        &#34;&#34;&#34;
        bl_idname = &#34;kawa.select_vertices_affected_by_shape_key&#34;
        bl_label = &#34;Select Vertices Affected by Active Shape Key&#34;
        bl_description = &#34;Select Vertices Affected by Active Shape Key.&#34;
        bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}

        epsilon: _bpy.props.FloatProperty(
                name=&#34;Epsilon&#34;,
                description=&#34;Selection precision in local space&#34;,
                min=1e-07,
                default=1e-06,
                max=1,
                precision=6,
                unit=&#39;LENGTH&#39;
        )
        
        @classmethod
        def poll(cls, context: &#39;Context&#39;):
                obj = cls.get_active_obj(context)
                if not obj or obj.type != &#39;MESH&#39;:
                        return False  # Требуется активный меш-объект
                if not obj.active_shape_key or obj.active_shape_key_index == 0:
                        return False  # Требуется что бы был активный не первый шейпкей
                if context.mode != &#39;EDIT_MESH&#39; and context.mode != &#39;OBJECT&#39;:
                        return False  # Требуется режим OBJECT или EDIT_MESH
                return True
        
        def invoke(self, context: &#39;Context&#39;, event):
                wm = context.window_manager
                # return wm.invoke_props_popup(self, event)
                # return {&#39;RUNNING_MODAL&#39;}
                return wm.invoke_props_dialog(self)
        
        def execute(self, context: &#39;Context&#39;):
                # Рофл в том, что операции над мешью надо проводить вне эдит-мода
                _bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;, toggle=False)
                
                obj = self.get_active_obj(context)
                mesh = obj.data  # type: Mesh
                shape_key = obj.active_shape_key
                reference = mesh.shape_keys.reference_key
                
                match_skd = ensure_len_match(mesh, shape_key, op=self)
                match_ref = ensure_len_match(mesh, reference, op=self)
                if not match_skd or not match_ref:
                        return {&#39;CANCELLED&#39;}

                for p in mesh.polygons:
                        p.select = False
                for e in mesh.edges:
                        e.select = False
                
                counter = 0
                for i in range(len(mesh.vertices)):
                        mesh.vertices[i].select = (shape_key.data[i].co - reference.data[i].co).magnitude &gt; self.epsilon
                        counter += 1
                _log.info(&#34;Selected {0} vertices affected by {1} in {2}&#34;.format(counter, repr(shape_key), repr(obj)))
                
                _bpy.ops.object.mode_set_with_submode(mode=&#39;EDIT&#39;, toggle=False, mesh_select_mode={&#39;VERT&#39;})
                
                return {&#39;FINISHED&#39;}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>kawa_scripts._internals.KawaOperator</li>
<li>bpy.types.Operator</li>
<li>bpy.types.bpy_struct</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kawa_scripts.shapekeys.OperatorSelectVerticesAffectedByShapeKey.epsilon"><code class="name">var <span class="ident">epsilon</span> : None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="kawa_scripts" href="index.html">kawa_scripts</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="kawa_scripts.shapekeys.apply_active_to_all" href="#kawa_scripts.shapekeys.apply_active_to_all">apply_active_to_all</a></code></li>
<li><code><a title="kawa_scripts.shapekeys.apply_active_to_basis" href="#kawa_scripts.shapekeys.apply_active_to_basis">apply_active_to_basis</a></code></li>
<li><code><a title="kawa_scripts.shapekeys.cleanup_active" href="#kawa_scripts.shapekeys.cleanup_active">cleanup_active</a></code></li>
<li><code><a title="kawa_scripts.shapekeys.cleanup_all" href="#kawa_scripts.shapekeys.cleanup_all">cleanup_all</a></code></li>
<li><code><a title="kawa_scripts.shapekeys.ensure_len_match" href="#kawa_scripts.shapekeys.ensure_len_match">ensure_len_match</a></code></li>
<li><code><a title="kawa_scripts.shapekeys.remove_empty" href="#kawa_scripts.shapekeys.remove_empty">remove_empty</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="kawa_scripts.shapekeys.OperatorApplyActiveToAll" href="#kawa_scripts.shapekeys.OperatorApplyActiveToAll">OperatorApplyActiveToAll</a></code></h4>
<ul class="">
<li><code><a title="kawa_scripts.shapekeys.OperatorApplyActiveToAll.keep_reverted" href="#kawa_scripts.shapekeys.OperatorApplyActiveToAll.keep_reverted">keep_reverted</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kawa_scripts.shapekeys.OperatorApplyActiveToBasis" href="#kawa_scripts.shapekeys.OperatorApplyActiveToBasis">OperatorApplyActiveToBasis</a></code></h4>
<ul class="">
<li><code><a title="kawa_scripts.shapekeys.OperatorApplyActiveToBasis.keep_reverted" href="#kawa_scripts.shapekeys.OperatorApplyActiveToBasis.keep_reverted">keep_reverted</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kawa_scripts.shapekeys.OperatorApplySelectedInActiveToAll" href="#kawa_scripts.shapekeys.OperatorApplySelectedInActiveToAll">OperatorApplySelectedInActiveToAll</a></code></h4>
</li>
<li>
<h4><code><a title="kawa_scripts.shapekeys.OperatorApplySelectedInActiveToBasis" href="#kawa_scripts.shapekeys.OperatorApplySelectedInActiveToBasis">OperatorApplySelectedInActiveToBasis</a></code></h4>
</li>
<li>
<h4><code><a title="kawa_scripts.shapekeys.OperatorCleanupActive" href="#kawa_scripts.shapekeys.OperatorCleanupActive">OperatorCleanupActive</a></code></h4>
<ul class="">
<li><code><a title="kawa_scripts.shapekeys.OperatorCleanupActive.epsilon" href="#kawa_scripts.shapekeys.OperatorCleanupActive.epsilon">epsilon</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kawa_scripts.shapekeys.OperatorCleanupAll" href="#kawa_scripts.shapekeys.OperatorCleanupAll">OperatorCleanupAll</a></code></h4>
<ul class="">
<li><code><a title="kawa_scripts.shapekeys.OperatorCleanupAll.epsilon" href="#kawa_scripts.shapekeys.OperatorCleanupAll.epsilon">epsilon</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kawa_scripts.shapekeys.OperatorRemoveEmpty" href="#kawa_scripts.shapekeys.OperatorRemoveEmpty">OperatorRemoveEmpty</a></code></h4>
<ul class="">
<li><code><a title="kawa_scripts.shapekeys.OperatorRemoveEmpty.epsilon" href="#kawa_scripts.shapekeys.OperatorRemoveEmpty.epsilon">epsilon</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kawa_scripts.shapekeys.OperatorRevertSelectedInActiveToBasis" href="#kawa_scripts.shapekeys.OperatorRevertSelectedInActiveToBasis">OperatorRevertSelectedInActiveToBasis</a></code></h4>
</li>
<li>
<h4><code><a title="kawa_scripts.shapekeys.OperatorRevertSelectedInAllToBasis" href="#kawa_scripts.shapekeys.OperatorRevertSelectedInAllToBasis">OperatorRevertSelectedInAllToBasis</a></code></h4>
</li>
<li>
<h4><code><a title="kawa_scripts.shapekeys.OperatorSelectVerticesAffectedByShapeKey" href="#kawa_scripts.shapekeys.OperatorSelectVerticesAffectedByShapeKey">OperatorSelectVerticesAffectedByShapeKey</a></code></h4>
<ul class="">
<li><code><a title="kawa_scripts.shapekeys.OperatorSelectVerticesAffectedByShapeKey.epsilon" href="#kawa_scripts.shapekeys.OperatorSelectVerticesAffectedByShapeKey.epsilon">epsilon</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> ???</a>.</p>
</footer>
</body>
</html>